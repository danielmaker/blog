<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>深入淺出 start_kernel() &mdash; Daniel Jslin</title>
  <meta name="author" content="Daniel Lin">

  <link href="https://danielmaker.github.io/blog/feeds/atom.xml" type="application/atom+xml" rel="alternate"
        title="Daniel Jslin Atom Feed" />
  <link href="https://danielmaker.github.io/blog/feeds/rss.xml" type="application/rss+xml" rel="alternate"
        title="Daniel Jslin RSS Feed" />





  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">


    <link href="https://danielmaker.github.io/blog/favicon.png" rel="icon">

  <link href="https://danielmaker.github.io/blog/theme/css/main.css" media="screen, projection"
        rel="stylesheet" type="text/css">

  <link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic"
        rel="stylesheet" type="text/css">
  <link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic"
        rel="stylesheet" type="text/css">
</head>

<body>
  <header role="banner"><hgroup>
  <h1><a href="https://danielmaker.github.io/blog/">Daniel Jslin</a></h1>
    <h2>May the source be with you</h2>
</hgroup></header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="https://danielmaker.github.io/blog/feeds/atom.xml" rel="subscribe-atom">Atom</a></li>
  <li><a href="https://danielmaker.github.io/blog/feeds/rss.xml" rel="subscribe-rss">RSS</a></li>
</ul>

<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="danielmaker.github.io/blog">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>

<ul class="main-navigation">
      <li >
        <a href="https://danielmaker.github.io/blog/category/about.html">About</a>
      </li>
      <li class="active">
        <a href="https://danielmaker.github.io/blog/category/linux.html">Linux</a>
      </li>
</ul></nav>
  <div id="main">
    <div id="content">
<div>
  <article class="hentry" role="article">
<header>
      <h1 class="entry-title">深入淺出 start_kernel()</h1>
    <p class="meta">
<time datetime="2016-05-16T00:00:00+08:00" pubdate>2016-05-16, Mon</time>    </p>
</header>

  <div class="entry-content"><p>當 bootloader 載入核心映像檔(zImage, or bzImage) 之後，在核心映像檔最開頭的 bootstrap code 會負責關閉中斷，初始化記憶體設定等硬體初始化工作，最後解壓縮內核。
不同的硬體架構會有不同的設定方式，大致的流程如下圖所示：</p>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<!-- Generated by graphviz version 2.38.0 (20140413.2041)
 -->
<!-- Title: start_kernel Pages: 1 -->
<svg width="366pt" height="286pt"
 viewBox="0.00 0.00 366.19 286.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 282)">
<title>start_kernel</title>
<!-- booting -->
<g id="node1" class="node"><title>booting</title>
<polygon fill="lightgrey" stroke="black" points="223.382,-278 80.1821,-278 80.1821,-242 223.382,-242 223.382,-278"/>
<text text-anchor="middle" x="151.782" y="-255.8" font-family="monospace" font-size="14.00">arch/*/boot/</text>
</g>
<!-- low_level_init -->
<g id="node2" class="node"><title>low_level_init</title>
<polygon fill="lightgrey" stroke="black" points="303.347,-136 0.217461,-136 0.217461,-100 303.347,-100 303.347,-136"/>
<text text-anchor="middle" x="151.782" y="-113.8" font-family="monospace" font-size="14.00">arch/*/kernel/head*.S, head*.c</text>
</g>
<!-- booting&#45;&gt;low_level_init -->
<g id="edge1" class="edge"><title>booting&#45;&gt;low_level_init</title>
<path fill="none" stroke="black" d="M151.782,-241.833C151.782,-218.007 151.782,-174.658 151.782,-146.349"/>
<polygon fill="black" stroke="black" points="155.282,-146.307 151.782,-136.307 148.282,-146.307 155.282,-146.307"/>
<text text-anchor="start" x="151.782" y="-212.8" font-family="Times,serif" font-size="14.00"> &#160;&#160;Booting </text>
<text text-anchor="start" x="151.782" y="-198.8" font-family="Times,serif" font-size="14.00"> &#160;&#160;&#45; disable interrupt </text>
<text text-anchor="start" x="151.782" y="-184.8" font-family="Times,serif" font-size="14.00"> &#160;&#160;&#45; prepare memory </text>
<text text-anchor="start" x="151.782" y="-170.8" font-family="Times,serif" font-size="14.00"> &#160;&#160;&#45; clean bss section </text>
<text text-anchor="start" x="151.782" y="-156.8" font-family="Times,serif" font-size="14.00"> &#160;&#160;&#45; decompress zImage (or bzImag) &#160;</text>
</g>
<!-- start_kernel -->
<g id="node3" class="node"><title>start_kernel</title>
<polygon fill="#66ff99" stroke="black" points="286.551,-36 17.0135,-36 17.0135,-0 286.551,-0 286.551,-36"/>
<text text-anchor="middle" x="151.782" y="-13.8" font-family="monospace" font-size="14.00">init/main.c: start_kernel()</text>
</g>
<!-- low_level_init&#45;&gt;start_kernel -->
<g id="edge2" class="edge"><title>low_level_init&#45;&gt;start_kernel</title>
<path fill="none" stroke="black" d="M151.782,-99.9297C151.782,-85.1248 151.782,-63.432 151.782,-46.2312"/>
<polygon fill="black" stroke="black" points="155.282,-46.2035 151.782,-36.2035 148.282,-46.2035 155.282,-46.2035"/>
<text text-anchor="start" x="151.782" y="-70.8" font-family="Times,serif" font-size="14.00"> &#160;&#160;Low&#45;level initialization </text>
<text text-anchor="start" x="151.782" y="-56.8" font-family="Times,serif" font-size="14.00"> &#160;&#160;&#45; switch to virtual memory </text>
</g>
</g>
</svg>
<p>在 start_kernel() 之前的 bootstrap code 最主要的任務就是將環境準備好，滿足 start_kernel()
的要求，然後就轉到 start_kernel() ， 由 start_kernel() 開始進行一般化 (generic and architecture independent)
的初始化流程。</p>
<p><a class="reference external" href="http://lxr.free-electrons.com/source/init/main.c?v=4.1#L492">start_kernel()</a> 是核心的主要進入點，核心從這裡開始走訪各個子系統的初始化函式。
以下是 version 4.1.15 的 start_kernel() ，大約呼叫了一百個左右的函式。若每個函式都能理解的話，那麼我想對 Linux kernel 也就有相當的了解了。
下面將 start_kernel() 呼叫到的函式加上註解說明，方便大家理解各個函式的作用。</p>
<blockquote>
<div class="highlight"><pre><span class="n">asmlinkage</span> <span class="n">__visible</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">start_kernel</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">command_line</span><span class="p">;</span>  <span class="c1">// a pointer to the kernel command line</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">after_dashes</span><span class="p">;</span>  <span class="c1">// a pointer to the kernel command line after &quot;--&quot;, which will be passed to the init process</span>

    <span class="cm">/*</span>
<span class="cm">     * Need to run as early as possible, to initialize the</span>
<span class="cm">     * lockdep hash:</span>
<span class="cm">     */</span>
    <span class="n">lockdep_init</span><span class="p">();</span>             <span class="c1">// lock dependency validator, https://www.kernel.org/doc/Documentation/locking/lockdep-design.txt</span>
    <span class="n">set_task_stack_end_magic</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_task</span><span class="p">);</span>  <span class="c1">// setup magic number in the end of stack of init_task for overflow detection</span>
    <span class="n">smp_setup_processor_id</span><span class="p">();</span>   <span class="c1">// assign SMP CPU id. archs can override it.</span>
    <span class="n">debug_objects_early_init</span><span class="p">();</span> <span class="c1">// infrastructure for lifetime debugging of objects, https://lwn.net/Articles/271614/</span>

    <span class="cm">/*</span>
<span class="cm">     * Set up the the initial canary ASAP:</span>
<span class="cm">     */</span>
    <span class="n">boot_init_stack_canary</span><span class="p">();</span>   <span class="c1">// stack smashing protector, http://wiki.osdev.org/Stack_Smashing_Protector</span>

    <span class="n">cgroup_init_early</span><span class="p">();</span>        <span class="c1">// initialize cgroup subsystems, https://en.wikipedia.org/wiki/Cgroups</span>

    <span class="n">local_irq_disable</span><span class="p">();</span>        <span class="c1">// disable IRQ first because interrupt vector table has not been setup yet</span>
    <span class="n">early_boot_irqs_disabled</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Interrupts are still disabled. Do necessary setups, then</span>
<span class="cm"> * enable them</span>
<span class="cm"> */</span>
    <span class="n">boot_cpu_init</span><span class="p">();</span>                  <span class="c1">// activate the first processor. mark the boot cpu &quot;present&quot;, &quot;online&quot; etc for SMP and UP case</span>
    <span class="n">page_address_init</span><span class="p">();</span>              <span class="c1">// initializes page_address_htable</span>
    <span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">linux_banner</span><span class="p">);</span>
<span class="hll">    <span class="n">setup_arch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">command_line</span><span class="p">);</span>        <span class="c1">// architecture-specific setup</span>
</span>    <span class="n">mm_init_cpumask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">init_mm</span><span class="p">);</span>        <span class="c1">// =&gt; cpumask_clear(mm-&gt;cpu_vm_mask_var), for lazy TLB switches</span>
    <span class="n">setup_command_line</span><span class="p">(</span><span class="n">command_line</span><span class="p">);</span> <span class="c1">// store the untouched command line</span>
    <span class="n">setup_nr_cpu_ids</span><span class="p">();</span>               <span class="c1">// set &quot;nr_cpu_ids&quot; according to the last bit in possible mask</span>
    <span class="n">setup_per_cpu_areas</span><span class="p">();</span>            <span class="c1">// per cpu memory allocator</span>
    <span class="n">smp_prepare_boot_cpu</span><span class="p">();</span> <span class="cm">/* arch-specific boot-cpu hooks */</span>

    <span class="n">build_all_zonelists</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>  <span class="c1">// memory zones, https://www.kernel.org/doc/gorman/html/understand/understand005.html</span>
    <span class="n">page_alloc_init</span><span class="p">();</span>                <span class="c1">// add a handler for CPU hotplug</span>

    <span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;Kernel command line: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">boot_command_line</span><span class="p">);</span>
    <span class="n">parse_early_param</span><span class="p">();</span>              <span class="c1">// parse options for early_param()</span>
    <span class="n">after_dashes</span> <span class="o">=</span> <span class="n">parse_args</span><span class="p">(</span><span class="s">&quot;Booting kernel&quot;</span><span class="p">,</span>
                  <span class="n">static_command_line</span><span class="p">,</span> <span class="n">__start___param</span><span class="p">,</span>  <span class="c1">// parse options for module_param(), module_param_named(), core_param()</span>
                  <span class="n">__stop___param</span> <span class="o">-</span> <span class="n">__start___param</span><span class="p">,</span>
                  <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">unknown_bootoption</span><span class="p">);</span>          <span class="c1">// parse options for __setup()</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">after_dashes</span><span class="p">))</span>
        <span class="n">parse_args</span><span class="p">(</span><span class="s">&quot;Setting init args&quot;</span><span class="p">,</span> <span class="n">after_dashes</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="c1">// after_dashes will be passed to the init process as argv</span>
               <span class="n">set_init_arg</span><span class="p">);</span>

    <span class="n">jump_label_init</span><span class="p">();</span>         <span class="c1">// Jump label: https://lwn.net/Articles/412072/</span>

    <span class="cm">/*</span>
<span class="cm">     * These use large bootmem allocations and must precede</span>
<span class="cm">     * kmem_cache_init()</span>
<span class="cm">     */</span>
    <span class="n">setup_log_buf</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>          <span class="c1">// buf for printk</span>
    <span class="n">pidhash_init</span><span class="p">();</span>            <span class="c1">// pid hash table</span>
    <span class="n">vfs_caches_init_early</span><span class="p">();</span>   <span class="c1">// allocate and caches initialize for hash tables of dcache and inode</span>
    <span class="n">sort_main_extable</span><span class="p">();</span>       <span class="c1">// sort the kernel&#39;s built-in exception table (for page faults)</span>
    <span class="n">trap_init</span><span class="p">();</span>               <span class="c1">// architecture-specific, interrupt vector table, handle hardware traps, exceptions and faults.</span>
<span class="hll">    <span class="n">mm_init</span><span class="p">();</span>                 <span class="c1">// memory management</span>
</span>
    <span class="cm">/*</span>
<span class="cm">     * Set up the scheduler prior starting any interrupts (such as the</span>
<span class="cm">     * timer interrupt). Full topology setup happens at smp_init()</span>
<span class="cm">     * time - but meanwhile we still have a functioning scheduler.</span>
<span class="cm">     */</span>
<span class="hll">    <span class="n">sched_init</span><span class="p">();</span>
</span>    <span class="cm">/*</span>
<span class="cm">     * Disable preemption - early bootup scheduling is extremely</span>
<span class="cm">     * fragile until we cpu_idle() for the first time.</span>
<span class="cm">     */</span>
    <span class="n">preempt_disable</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">WARN</span><span class="p">(</span><span class="o">!</span><span class="n">irqs_disabled</span><span class="p">(),</span> <span class="s">&quot;Interrupts were enabled *very* early, fixing it</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">))</span>
        <span class="n">local_irq_disable</span><span class="p">();</span>
    <span class="n">idr_init_cache</span><span class="p">();</span>          <span class="c1">// idr: ID radix, sparse array indexed by the id to obtain the pointer</span>
    <span class="n">rcu_init</span><span class="p">();</span>                <span class="c1">// Read-Copy Update mechanism, https://www.kernel.org/doc/Documentation/RCU/</span>

    <span class="cm">/* trace_printk() and trace points may be used after this */</span>
    <span class="n">trace_init</span><span class="p">();</span>              <span class="c1">// https://www.kernel.org/doc/Documentation/trace/</span>

    <span class="n">context_tracking_init</span><span class="p">();</span>   <span class="c1">// prepare for using a static key in the context tracking subsystem</span>
    <span class="n">radix_tree_init</span><span class="p">();</span>         <span class="c1">// allocate a cache for radix_tree. [LWN] radix_tree: https://lwn.net/Articles/175432/</span>
    <span class="cm">/* init some links before init_ISA_irqs() */</span>
    <span class="n">early_irq_init</span><span class="p">();</span>          <span class="c1">// allocate caches for irq_desc, interrupt descriptor</span>
    <span class="n">init_IRQ</span><span class="p">();</span>                <span class="c1">// architecture-specific, initialize kernel&#39;s interrupt subsystem and the interrupt controllers.</span>
    <span class="n">tick_init</span><span class="p">();</span>               <span class="c1">// initialize the tick control</span>
    <span class="n">rcu_init_nohz</span><span class="p">();</span>
    <span class="n">init_timers</span><span class="p">();</span>             <span class="c1">// init timer stats, register cpu notifier, and open softirq for timer</span>
    <span class="n">hrtimers_init</span><span class="p">();</span>           <span class="c1">// high-resolution timer, https://www.kernel.org/doc/Documentation/timers/hrtimers.txt</span>
    <span class="n">softirq_init</span><span class="p">();</span>            <span class="c1">// initialize tasklet_vec and open softirq for tasklet</span>
    <span class="n">timekeeping_init</span><span class="p">();</span>        <span class="c1">// https://www.kernel.org/doc/Documentation/timers/timekeeping.txt</span>
    <span class="n">time_init</span><span class="p">();</span>               <span class="c1">// architecture-specific, timer initialization</span>
    <span class="n">sched_clock_postinit</span><span class="p">();</span>    <span class="c1">// start the high-resolution timer to keep sched_clock() properly updated and sets the initial epoch</span>
    <span class="n">perf_event_init</span><span class="p">();</span>         <span class="c1">// perf is a profiler tool for Linux, https://perf.wiki.kernel.org/index.php/Tutorial</span>
    <span class="n">profile_init</span><span class="p">();</span>            <span class="c1">// initializes basic kernel profiler</span>
    <span class="n">call_function_init</span><span class="p">();</span>      <span class="c1">// SMP initializes call_single_queue and register notifier</span>
    <span class="n">WARN</span><span class="p">(</span><span class="o">!</span><span class="n">irqs_disabled</span><span class="p">(),</span> <span class="s">&quot;Interrupts were enabled early</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">early_boot_irqs_disabled</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">local_irq_enable</span><span class="p">();</span>        <span class="c1">// after this point, interrupts are enabled</span>

    <span class="n">kmem_cache_init_late</span><span class="p">();</span>    <span class="c1">// post-initialization of cache (slab)</span>

    <span class="cm">/*</span>
<span class="cm">     * HACK ALERT! This is early. We&#39;re enabling the console before</span>
<span class="cm">     * we&#39;ve done PCI setups etc, and console_init() must be aware of</span>
<span class="cm">     * this. But we do want output early, in case something goes wrong.</span>
<span class="cm">     */</span>
    <span class="n">console_init</span><span class="p">();</span>            <span class="c1">// call console initcalls to initialize the console device, usually it&#39;s tty device.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">panic_later</span><span class="p">)</span>
        <span class="n">panic</span><span class="p">(</span><span class="s">&quot;Too many boot %s vars at `%s&#39;&quot;</span><span class="p">,</span> <span class="n">panic_later</span><span class="p">,</span>
              <span class="n">panic_param</span><span class="p">);</span>

    <span class="n">lockdep_info</span><span class="p">();</span>            <span class="c1">// print lockdep information</span>

    <span class="cm">/*</span>
<span class="cm">     * Need to run this when irqs are enabled, because it wants</span>
<span class="cm">     * to self-test [hard/soft]-irqs on/off lock inversion bugs</span>
<span class="cm">     * too:</span>
<span class="cm">     */</span>
    <span class="n">locking_selftest</span><span class="p">();</span>        <span class="c1">// test various locking APIs: spinlocks, rwlocks, mutexes, and rwsemaphores</span>

<span class="cp">#ifdef CONFIG_BLK_DEV_INITRD</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">initrd_start</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">initrd_below_start_ok</span> <span class="o">&amp;&amp;</span>
        <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">initrd_start</span><span class="p">))</span> <span class="o">&lt;</span> <span class="n">min_low_pfn</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pr_crit</span><span class="p">(</span><span class="s">&quot;initrd overwritten (0x%08lx &lt; 0x%08lx) - disabling it.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
            <span class="n">page_to_pfn</span><span class="p">(</span><span class="n">virt_to_page</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">initrd_start</span><span class="p">)),</span>
            <span class="n">min_low_pfn</span><span class="p">);</span>
        <span class="n">initrd_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="cp">#endif</span>
    <span class="n">page_ext_init</span><span class="p">();</span>           <span class="c1">// memory page extension, allocates memory for extended data per page</span>
    <span class="n">debug_objects_mem_init</span><span class="p">();</span>  <span class="c1">// allocate a dedicated cache pool for debug objects</span>
    <span class="n">kmemleak_init</span><span class="p">();</span>           <span class="c1">// initialize kmemleak (memory leak check facility)</span>
    <span class="n">setup_per_cpu_pageset</span><span class="p">();</span>   <span class="c1">// allocate and initialize per cpu pagesets</span>
    <span class="n">numa_policy_init</span><span class="p">();</span>        <span class="c1">// allocate caches and do initialization for NUMA memory policy</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">late_time_init</span><span class="p">)</span>        <span class="c1">// default late_time_init is NULL. archs can override it</span>
        <span class="n">late_time_init</span><span class="p">();</span>      <span class="c1">// architecture-specific</span>
    <span class="n">sched_clock_init</span><span class="p">();</span>        <span class="c1">// set the time info for scheduler and make sched clock running</span>
    <span class="n">calibrate_delay</span><span class="p">();</span>         <span class="c1">// calibrate the delay loop</span>
    <span class="n">pidmap_init</span><span class="p">();</span>             <span class="c1">// initialize PID map for initial PID namespace</span>
    <span class="n">anon_vma_init</span><span class="p">();</span>           <span class="c1">// allocate a cache for &quot;anon_vma&quot; (anonymous memory), http://lwn.net/Kernel/Index/#anon_vma</span>
    <span class="n">acpi_early_init</span><span class="p">();</span>         <span class="c1">// initialize ACPI subsystem and populate the ACPI namespace</span>
<span class="cp">#ifdef CONFIG_X86</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">efi_enabled</span><span class="p">(</span><span class="n">EFI_RUNTIME_SERVICES</span><span class="p">))</span>  <span class="c1">// Extensible Firmware Interface</span>
        <span class="n">efi_enter_virtual_mode</span><span class="p">();</span>           <span class="c1">// switch EFI to virtual mode, if possible</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_X86_ESPFIX64</span>
    <span class="cm">/* Should be run before the first non-init thread is created */</span>
    <span class="n">init_espfix_bsp</span><span class="p">();</span>         <span class="c1">// workaround to prevent leaking of 31:16 bits of the esp register, https://github.com/torvalds/linux/commit/3891a04aafd668686239349ea58f3314ea2af86b</span>
<span class="cp">#endif</span>
    <span class="n">thread_info_cache_init</span><span class="p">();</span>  <span class="c1">// allocate cache for thread_info if THREAD_SIZE &lt; PAGE_SIZE</span>
    <span class="n">cred_init</span><span class="p">();</span>               <span class="c1">// credential</span>
    <span class="n">fork_init</span><span class="p">();</span>               <span class="c1">// allocate a cache for task_struct</span>
    <span class="n">proc_caches_init</span><span class="p">();</span>        <span class="c1">// allocate caches for sighand_struct, signal_struct, files_struct, fs_struct, mm_struct, and vm_area_struct</span>
    <span class="n">buffer_init</span><span class="p">();</span>             <span class="c1">// allocate a cache for buffer_head</span>
    <span class="n">key_init</span><span class="p">();</span>                <span class="c1">// initialize the authentication token and access key management</span>
    <span class="n">security_init</span><span class="p">();</span>           <span class="c1">// initialize the security framework, do_security_initcalls</span>
    <span class="n">dbg_late_init</span><span class="p">();</span>           <span class="c1">// late init for kgdb</span>
<span class="hll">    <span class="n">vfs_caches_init</span><span class="p">(</span><span class="n">totalram_pages</span><span class="p">);</span>  <span class="c1">// file system, including kernfs, sysfs, rootfs, mount tree</span>
</span>    <span class="n">signals_init</span><span class="p">();</span>            <span class="c1">// allocate a cache for sigqueue</span>
    <span class="cm">/* rootfs populating might need page-writeback */</span>
    <span class="n">page_writeback_init</span><span class="p">();</span>     <span class="c1">// set the ratio limits for the dirty pages</span>
    <span class="n">proc_root_init</span><span class="p">();</span>          <span class="c1">// initializes /proc filesystem, and creates several standard entries like /proc/fs and /proc/driver</span>
    <span class="n">nsfs_init</span><span class="p">();</span>               <span class="c1">// mount pseudo-filesystem: nsfs</span>
    <span class="n">cpuset_init</span><span class="p">();</span>             <span class="c1">// initialize top_cpuset and the cpuset internal file system</span>
    <span class="n">cgroup_init</span><span class="p">();</span>             <span class="c1">// initialize the rest of cgroups</span>
    <span class="n">taskstats_init_early</span><span class="p">();</span>    <span class="c1">// allocate a cache and initialize per-task statistics</span>
    <span class="n">delayacct_init</span><span class="p">();</span>          <span class="c1">// per-task delay accounting</span>

    <span class="n">check_bugs</span><span class="p">();</span>              <span class="c1">// check for architecture-dependent bugs</span>

    <span class="n">acpi_subsystem_init</span><span class="p">();</span>     <span class="c1">// enable ACPI subsystem</span>
    <span class="n">sfi_init_late</span><span class="p">();</span>           <span class="c1">// SFI: Simple Firmware Interface. Map SFI tables again by using ioremap</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">efi_enabled</span><span class="p">(</span><span class="n">EFI_RUNTIME_SERVICES</span><span class="p">))</span> <span class="p">{</span>  <span class="c1">// Extensible Firmware Interface</span>
        <span class="n">efi_late_init</span><span class="p">();</span>
        <span class="n">efi_free_boot_services</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="n">ftrace_init</span><span class="p">();</span>             <span class="c1">// function trace, https://www.kernel.org/doc/Documentation/trace/ftrace.txt</span>

    <span class="cm">/* Do the rest non-__init&#39;ed, we&#39;re now alive */</span>
    <span class="n">rest_init</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</blockquote>
<div class="section" id="id2">
<h2>關於 start_kernel() 的說明</h2>
<p>以下將對 start_kernel() 所牽涉到的內核功能及特色 (feature) 做簡單說明及介紹。
由於我只是一個對 Linux 核心有興趣的業餘愛好者，並沒有實際從事跟核心相關的開發工作，對核心許多相關的主題只有粗淺的認識，缺乏更深入的了解，以下的說明將以觀念介紹為主，不對細節做太深入的探討。</p>
<p>在 start_kernel() 的一開始，核心先對除錯機制進行初始化，除了 smp_setup_processor_id() 之外，其它四個函式呼叫都是核心用來除錯的機制。</p>
<blockquote>
<pre class="code literal-block">
lockdep_init();
set_task_stack_end_magic(&amp;init_task);
smp_setup_processor_id();
debug_objects_early_init();
boot_init_stack_canary();
</pre>
</blockquote>
<div class="section" id="lockdep">
<h3>lockdep</h3>
<p>lockdep 是核心用來檢查死鎖的機制，它會檢查一些會造成死鎖的上鎖方式，如重複上鎖 (AA)，不一致的上鎖順序 (AB-BA) 等問題。當它偵測到問題時會發出如下的警告:</p>
<blockquote>
<pre class="code literal-block">
modprobe/2287 is trying to acquire lock:
 (&amp;sio_locks[i].lock){-.-...}, at: [&lt;c02867fd&gt;] mutex_lock+0x21/0x24

but task is already holding lock:
 (&amp;sio_locks[i].lock){-.-...}, at: [&lt;c02867fd&gt;] mutex_lock+0x21/0x24
</pre>
</blockquote>
<p>通常死鎖的問題很難重現，這增加了除錯的困難。
lockdep 的強大之處在於它不需要等到真正發生死鎖之後才回報問題，它被設計成只要發現只要發現有造成死鎖疑慮的上鎖步驟就會發出警告。</p>
<p>不過由於內核非常頻繁地在上鎖解鎖，lockdep 的檢查無可避免地會拖慢系統的速度，在正式上線的內核不會將這個檢查打開，通常是在內部測試時會設定 CONFIG_LOCKDEP 啟動 lockdep 的檢查。</p>
<p>由於 lockdep 實在太有用了，這個功能後來也變成一個獨立的工具，放在 tools/lib/lockdep/ 之下，讓 user space 的應用程式也能利用 lockdep 檢查死鎖。</p>
<ul class="simple">
<li><a class="reference external" href="https://www.kernel.org/doc/Documentation/locking/lockdep-design.txt">https://www.kernel.org/doc/Documentation/locking/lockdep-design.txt</a></li>
<li><a class="reference external" href="https://lwn.net/Articles/185666/">LWN: The kernel lock validator</a></li>
<li><a class="reference external" href="https://lwn.net/Articles/536363/">LWN: User-space lockdep</a></li>
</ul>
</div>
<div class="section" id="set-task-stack-end-magic">
<h3>set_task_stack_end_magic()</h3>
<p>set_task_stack_end_magic() 這個函式呼叫會在 task 的 stack 後面放一個檢查碼，
如果這個檢查碼的值被改變了，表示有人寫到 stack 以外的區域，也就是發生了 stack overflow。</p>
<blockquote>
<div class="highlight"><pre><span class="cp">#define STACK_END_MAGIC         0x57AC6E9D</span>

<span class="kt">void</span> <span class="nf">set_task_stack_end_magic</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">stackend</span><span class="p">;</span>

    <span class="n">stackend</span> <span class="o">=</span> <span class="n">end_of_stack</span><span class="p">(</span><span class="n">tsk</span><span class="p">);</span>
    <span class="o">*</span><span class="n">stackend</span> <span class="o">=</span> <span class="n">STACK_END_MAGIC</span><span class="p">;</span>    <span class="cm">/* for overflow detection */</span>
<span class="p">}</span>
</pre></div>
</blockquote>
</div>
<div class="section" id="debug-objects">
<h3>debug objects</h3>
<p>debug objects 是針對核心內部物件的生命週期管理除錯的設施。根據原作者 Thomas Gleixner 的說明，
在核心開發常常會遇到物件的生命週期管理相關的錯誤，如:</p>
<ol class="arabic simple">
<li>使用已經被釋放的物件</li>
<li>重新初始化已經在作用的物件</li>
</ol>
<p>像這樣的問題很難被除錯，因為發生問題的點常不是問題的源頭 (root cause)。
以「使用已經被釋放的物件」這類型的錯誤來說，真正的問題可能是物件釋放的時間點不對。</p>
<p>debug objects 就是設計來追蹤這一類關於物件生命週期管理相關的問題，子系統只需在相對應的函式加入
debug objects 的函式就可以利用它來幫忙追蹤物件的生命週期。
debug objects 原先是設計來追蹤 timer 的生命週期管理，除了 timer 以外，目前 worker queue 也有使用。</p>
<ul class="simple">
<li><a class="reference external" href="https://lwn.net/Articles/271582/">LWN: object debugging infrastructure</a></li>
<li><a class="reference external" href="https://lwn.net/Articles/271614/">LWN: An object debugging infrastructure</a></li>
</ul>
</div>
<div class="section" id="boot-init-stack-canary">
<h3>boot_init_stack_canary()</h3>
<p>這邊的 stack canary (金絲雀) 和上面 stack end magic 是同樣作用，都是放在 stack 後面用來檢查是否發生
stack overflow。 內核這邊的 boot_init_stack_canary() 函式的功用是設定一個不固定的 stack canary 值，用以防止 stack overflow 的攻擊，不過內核這邊也僅僅是設定一個不固定的 canary 值，真正的檢查
stack overflow 的機制是由 gcc 實現。 gcc 提供 -fstack-protector 編譯選項，它會參考這個 canary 值，
加入用來檢查的程式碼，在函式返回前檢查這個值是否被覆寫。 詳細的設明，推薦閱讀:
<a class="reference external" href="https://www.ibm.com/developerworks/cn/linux/l-cn-gccstack/">IBM developerWorks: GCC 中的编译器堆栈保护技术</a>。</p>
<p>到目前為此，核心都只是在初始化一些除錯相關的功能。
在 boot_init_stack_canary() 之後有一個比較奇怪的傢伙 cgroup_init_early()，這是我們比較不熟悉的。</p>
</div>
<div class="section" id="cgroup-control-group">
<h3>cgroup (control group)</h3>
<p>cgroup 是 control group 的簡稱，中文翻譯為控制群組。
cgroup 主要的功用是用來限制行程 (process) 對系統資源的使用，舉例來說，限制某個行程只能使用 20% 的 CPU，或是只使用 256MB 的 RAM。</p>
<p>整個 cgroup 子系統主要是由 cgroup core 及子系統控制器 (controller) 所組成，常見的 cgroup 控制器有:</p>
<ul class="simple">
<li>cpu: 限制控制群組中的任務 CPU 的使用量。</li>
<li>cpuset: 指派控制群組所使用的 CPU 與記憶體節點。</li>
<li>cpuacct: CPU accounting controller, 產生關於控制群組中的任務，CPU 資源使用的報告。</li>
<li>memmory: 限制控制群組中的任務所能使用的記憶體資源，並產生記憶體使用報告。</li>
<li>devices: 允許或拒絕控制群組中的任務存取特定裝置。</li>
<li>freezer: 中止或復原控制群組中的工作。</li>
<li>blkio: 設置對區塊設備的輸入輸出限制，限制存取功能或頻寬。</li>
<li>net_cls: Net class controller, 對網路封包標記 classid，讓流量控制器（tc）能夠辨識源自於特定控制群組的封包。</li>
<li>ns: Namespace, 以命名空間將控制群組中的任務隔離。</li>
</ul>
<p>cgroup 是以階層（hierarchy）的形式被組織在一起，下層可使用的資源由上層繼承而來，
也就是說上層會限制下層能使用的資源。
以下圖來說， top_cgroup (root) 擁有 100% 的系統資源，假設 group A 被限制只能使用 50% 的 CPU，那麼 group B 和 group C 就不能使用超過 50% 的 CPU。</p>
<blockquote>
<pre class="code literal-block">
            top_cgroup (root)
               /      \
        group A        group D
       /       \
group B         group C
</pre>
</blockquote>
<p>cgroup 最初是在 2008 年時進到核心版本 2.6.24 之中，但是初版 cgroup 的設計太過複雜為許多人所詬病，
因此 Tejun Heo 在 2012 年發起討論，提議重新設計 cgroup，
在 2013 年時，由他所主導的 cgroup v2 被整合到核心版本 3.15 和 3.16 之中。</p>
<p>新版的 cgroup 被稱為 cgroup v2，相較於舊版的 cgroup v1，它只允許一個唯一的階層（hierarchy）架構存在，這簡化了 cgroup 的設計。</p>
<p>在 start_kernel() 中， cgroup 的初始化分為兩個步驟: cgroup_init_early() 及 cgroup_init()。
cgroup_init_early() 會先對需要先初始化的子系統進行初始化，主要是 root cgroup 的子系統，接下來的 cgroup_init() 會完成後續整個 cgroup 子系統的初始化。</p>
<blockquote>
<div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> * cgroup_init_early - cgroup initialization at system boot</span>
<span class="cm"> *</span>
<span class="cm"> * Initialize cgroups at system boot, and initialize any</span>
<span class="cm"> * subsystems that request early init.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">cgroup_init_early</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="k">struct</span> <span class="n">cgroup_sb_opts</span> <span class="n">__initdata</span> <span class="n">opts</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">cgroup_subsys</span> <span class="o">*</span><span class="n">ss</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

    <span class="n">init_cgroup_root</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cgrp_dfl_root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opts</span><span class="p">);</span>
    <span class="n">cgrp_dfl_root</span><span class="p">.</span><span class="n">cgrp</span><span class="p">.</span><span class="n">self</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">CSS_NO_REF</span><span class="p">;</span>

    <span class="n">RCU_INIT_POINTER</span><span class="p">(</span><span class="n">init_task</span><span class="p">.</span><span class="n">cgroups</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">init_css_set</span><span class="p">);</span>

    <span class="n">for_each_subsys</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>

        <span class="p">...</span> <span class="n">omitted</span> <span class="p">...</span>

        <span class="n">ss</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">ss</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">cgroup_subsys_name</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">ss</span><span class="o">-&gt;</span><span class="n">early_init</span><span class="p">)</span>
<span class="hll">            <span class="n">cgroup_init_subsys</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="cm">/* early= */</span> <span class="nb">true</span><span class="p">);</span>
</span>    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</blockquote>
<ul class="simple">
<li><a class="reference external" href="https://access.redhat.com/documentation/zh-TW/Red_Hat_Enterprise_Linux/6/html/Resource_Management_Guide/ch01.html">Redhat: 控制群組（cgroup）簡介</a></li>
<li><a class="reference external" href="https://www.kernel.org/doc/Documentation/cgroup-v2.txt">https://www.kernel.org/doc/Documentation/cgroup-v2.txt</a></li>
<li><a class="reference external" href="https://www.kernel.org/doc/Documentation/cgroup-v1/">https://www.kernel.org/doc/Documentation/cgroup-v1/</a></li>
<li><a class="reference external" href="https://en.wikipedia.org/wiki/Cgroups">https://en.wikipedia.org/wiki/Cgroups</a></li>
</ul>
</div>
<div class="section" id="cpu-mask">
<h3>CPU mask</h3>
<blockquote>
<div class="highlight"><pre><span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">boot_cpu_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="n">smp_processor_id</span><span class="p">();</span>
    <span class="cm">/* Mark the boot cpu &quot;present&quot;, &quot;online&quot; etc for SMP and UP case */</span>
    <span class="n">set_cpu_online</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>   <span class="c1">// set this CPU are available for scheduling</span>
    <span class="n">set_cpu_active</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>   <span class="c1">// set this CPU are available to migration (for load balance)</span>
    <span class="n">set_cpu_present</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>  <span class="c1">// set this CPU are currently plugged in</span>
    <span class="n">set_cpu_possible</span><span class="p">(</span><span class="n">cpu</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span> <span class="c1">// set this CPU can be plugged in</span>
<span class="p">}</span>
</pre></div>
</blockquote>
<p>在 Linux 內核中主要有 4 個 cpu mask array 記錄 CPU 的使用情形</p>
<ul class="simple">
<li>cpu_possible_mask: 硬體上實際可用的 CPU， boot time 時決定</li>
<li>cpu_present_mask: 目前指派使用的 CPU</li>
<li>cpu_online_mask: 可以被排程的 CPU (boot CPU 以外的 CPU 由 smp_init() 完成 CPU 初始化後設定為 online)</li>
<li>cpu_active_mask: 可以依據 domain/group 進行排程的 CPU (負載平衡)</li>
</ul>
<p>如果 CONFIG_HOTPLUG_CPU 有設定的話，Linux 內核啟動支援 CPU hotplug 的機制。
這邊的 hotplug 不是指硬體上的熱插拔，而是指系統可以動態決定
CPU 的使用，系統可以經由設定 cpu_present_mask 決定要使用的 CPU，舉例來說，系統可以在低負載時將一些 CPU 關掉，節省電源的消秏。
除了 cpu_present_mask 可以由外部設定，其它的 3個 mask 都是唯讀，由核心維護。</p>
<p>關於 CPU mask 可以參考:</p>
<ul class="simple">
<li><a class="reference external" href="http://lxr.free-electrons.com/source/include/linux/cpumask.h?v=4.1">include/linux/cpumask.h</a></li>
<li><a class="reference external" href="https://www.kernel.org/doc/Documentation/cpu-hotplug.txt">https://www.kernel.org/doc/Documentation/cpu-hotplug.txt</a></li>
</ul>
</div>
<div class="section" id="memory-zones">
<h3>Memory zones</h3>
<p>一個 32位元的處理器最多只能定址 4GB 的記憶體，在一般 Linux 核心的設定中，這 4GB 會被切分為
user space 3GB 和 kernel space 1GB。 如果某個裝置配備超過 4GB 的記憶體，Linux 要怎麼利用4GB 以上的記憶體呢？</p>
<p>為了解決這個問題，Linux 引進了 high memory 機制，採用動態映射的方式將大於 4GB
的記憶體映射到 32位元的定址空間中。Linux 將實體記憶體 (Physical Address, PA)
區分為以下的區域 (zones):</p>
<ul class="simple">
<li>ZONE_DMA (0-16 MB): 保留給 x86 ISA/PCI DMA 的實體記憶體區域。某些古老的 x86 ISA DMA
只能定址 0-16MB 的記憶體位址。</li>
<li>ZONE_NORMAL (16-896 MB): 正常核心程式碼所能存取的區域。</li>
<li>ZONE_HIGHMEM (896 MB 以上): 動態映射的記憶體區域。</li>
</ul>
<p>另外有2個新的 zone type 被加入到核心中:</p>
<ul class="simple">
<li>ZONE_DMA32 (16MB-4G) : 在 64 位元系統 (e.g. x86_64) 新增的 zone，延伸 ZONE_DMA 到 4G 的定址空間。<ul>
<li><a class="reference external" href="https://lwn.net/Articles/152337/">LWN: Add 4GB DMA32 zone</a></li>
</ul>
</li>
<li>ZONE_MOVABLE: 這是一個 pseudo zone，經由搬移被標記 ZONE_MOVABLE 的 page 來避免記憶體的碎片化。<ul>
<li><a class="reference external" href="https://lwn.net/Articles/219589/">LWN: Create ZONE_MOVABLE to partition memory between movable and non-movable pages</a></li>
</ul>
</li>
</ul>
<p>這邊要注意的是，上面所說的記憶體區域都是指實體記憶體空間，另外，核心在實體記憶體上是被放在低位址，在記憶體映射 (Memory Mapping) 建立之後，才會被映射到虛擬記憶體 (Virtual Address, VA) 的高位址上。</p>
<blockquote>
<object data="images/memory_zones.svg" style="width: 75%;" type="image/svg+xml">
</object>
</blockquote>
<p>在核心 1G 的記憶體空間中，在 896MB 之後的 128MB 屬於 ZONE_HIGHMEM，保留給核心以動態映射的方式映射
high memory。 所以，放在這區的資料基本上是屬於間接存取，必須先完成映射後才能被存取。</p>
<p>ZONE_DMA 和 ZONE_HIGHMEM 不一定要存在，像 x86_64 就沒有 ZONE_HIGHMEM。除了 x86_32 以外，大部份的系統都只有 ZONE_NORMAL，因為現在的大部份裝置都沒有 DMA 定址的限制，所以就不需要 ZONE_DMA，而64位元系統沒有 4GB 的定址限制，因此 ZONE_HIGHMEM 就不需要了，而就算是 32位元系統，如果不打算配備到 4GB 以上的記憶體，也不需要使用 high memory。</p>
<p>如果核心有設 high memory 配置的話 (CONFIG_HIGHMEM)，page_address_init() 會負責初始化
high memory 的映射表；若沒有 high memory 配置，page_address_init() 就只是個空函式。</p>
<blockquote>
<div class="highlight"><pre><span class="cp">#if defined(HASHED_PAGE_VIRTUAL)</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">page_address</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">set_page_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">virtual</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">page_address_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cp">#if !defined(HASHED_PAGE_VIRTUAL) &amp;&amp; !defined(WANT_PAGE_VIRTUAL)</span>
<span class="cp">#define page_address(page) lowmem_page_address(page)</span>
<span class="cp">#define set_page_address(page, address)  do { } while(0)</span>
<span class="cp">#define page_address_init()  do { } while(0)</span>
<span class="cp">#endif</span>
</pre></div>
<div class="highlight"><pre><span class="cp">#if defined(HASHED_PAGE_VIRTUAL)</span>

<span class="p">...</span> <span class="n">omitted</span> <span class="p">...</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="n">page_address_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">page_address_htable</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page_address_htable</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lh</span><span class="p">);</span>
        <span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page_address_htable</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">lock</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cp">#endif  </span><span class="cm">/* defined(CONFIG_HIGHMEM) &amp;&amp; !defined(WANT_PAGE_VIRTUAL) */</span><span class="cp"></span>
</pre></div>
</blockquote>
</div>
<div class="section" id="memory-architecture">
<h3>Memory architecture</h3>
<p>在現代多處理器的系統中，處理器對記憶體的存取可以分為 UMA (Uniform memory access) 和
NUMA (Non-uniform memory access) 兩種架構。</p>
<p>在 UMA 架構下，CPU 共用同一個 Bus 存取記憶體，所以同時間只能允許一個 CPU 對 Memory 進行存取。很明顯地，記憶體的存取會是 UMA 架構的一個效能瓶頸。</p>
<blockquote>
<object data="images/UMA.svg" type="image/svg+xml">
</object>
</blockquote>
<p>為了改善 UMA 架構的記憶體存取瓶頸，NUMA 架構被提出，將 memory 分配到各個 CPU，成為各個 CPU 的
local memory，在 Linux 中稱為一個 node。屬於同一個 node 的 CPU 可以直接存取，不需經由 Bus；只有要存取其他 node 的 memory 時才需要經由 Bus。
從架構上可以理解，與存取 local memory 相比，存取其他 node 的 memory 需要花費較多的時間，不同於 UMA 存取所有的記憶體都花費一樣的時間，所以這樣的架構被稱為 Non-uniform memory access, NUMA。</p>
<blockquote>
<object data="images/NUMA.svg" type="image/svg+xml">
</object>
</blockquote>
<p>Memory node 在 Linux 核心中由 <a class="reference external" href="http://lxr.free-electrons.com/source/include/linux/mmzone.h?v=4.1#L706">pg_data_t</a>
來表示，每個 node 包含一到數個 <a class="reference external" href="http://lxr.free-electrons.com/source/include/linux/mmzone.h?v=4.1#L327">struct zone</a> ，由各個架構所提供的 setup_arch() 完成初始化。</p>
<ul class="simple">
<li><a class="reference external" href="https://www.kernel.org/doc/Documentation/vm/numa">https://www.kernel.org/doc/Documentation/vm/numa</a></li>
<li><a class="reference external" href="http://www.cc.ntu.edu.tw/chinese/epaper/0015/20101220_1508.htm">多核心計算環境—NUMA與CPUSET簡介</a></li>
<li><a class="reference external" href="https://software.intel.com/en-us/articles/optimizing-applications-for-numa">Intel: Optimizing Applications for NUMA</a></li>
</ul>
</div>
<div class="section" id="setup-arch">
<h3>setup_arch()</h3>
<p>setup_arch() 通常被定義在各個架構的 arch/xxx/kernel/setup.c 之內，負責與硬體架構相關的初始化設定，如 CPU, 記憶體, 中斷, I/O, DMA 等。 由於硬體設計不同，特性不同，應用不同，每個架構需要被初始化及設置的硬體及設置的方式都不相同，要了解這個函式必須要對目標架構的硬體特性有相當的了解。</p>
<p>不同架構的 setup_arch() 差異相當大，像 x86 架構支援功能多，硬體複雜度相對高，連帶它的 setup_arch() 也相對複雜，接近 400 多行，比 start_kernel() 還大；但 arm 架構的 setup_arch() 大概只有 70 多行，相對簡單許多。</p>
<ul class="simple">
<li><a class="reference external" href="http://lxr.free-electrons.com/source/arch/x86/kernel/setup.c?v=4.1#L861">arch/x86/kernel/setup.c: setup_arch()</a></li>
<li><a class="reference external" href="http://lxr.free-electrons.com/source/arch/arm/kernel/setup.c?v=4.1#L913">arch/arm/kernel/setup.c: setup_arch()</a></li>
</ul>
<p>要深入探討 setup_arch() 必須先說明目標架構的硬體，那須要另外寫一篇才有辦法講清楚，本篇的目標在探討 start_kernel()，不打算深入各別硬體架構的部份。</p>
</div>
<div class="section" id="mm-init-cpumask">
<h3>mm_init_cpumask()</h3>
<p>這個函式很單純，就是把 mm_struct 裡的 cpu_vm_mask_var 初始化為 0，它記錄與這個 mm_struct 有相關的 CPU。</p>
<blockquote>
<div class="highlight"><pre><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">mm_init_cpumask</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#ifdef CONFIG_CPUMASK_OFFSTACK</span>
    <span class="n">mm</span><span class="o">-&gt;</span><span class="n">cpu_vm_mask_var</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">cpumask_allocation</span><span class="p">;</span>
<span class="cp">#endif</span>
    <span class="n">cpumask_clear</span><span class="p">(</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">cpu_vm_mask_var</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</blockquote>
<p>在 OS 內部有一份記憶體映射表，用以將虛擬記憶體頁對應到實際的物理記憶體頁。
當每次存取虛擬記憶體位址時，都必須參照這份記憶體映射表，找到真正對應的物理記憶體位址。
這份記憶體映射表存放於記憶體中，但記憶體的存取速度跟不上 CPU 的速度，為了加速存取，CPU 內部有一份快取，稱為 TLB (Translation Lookaside Buffer)，CPU 會先看看 TLB 裡面有沒有要查找的位址，若沒有就需要去讀取記憶體中的映射表。</p>
<p>當記憶體映射表有更動用時，相關 CPU 的 TLB 也需要被更新 (flush)，
cpu_vm_mask_var 記錄了那些 CPU 需要被通知。
這個變數主要會經由 mm_cpumask() 這個 inline 函式存取:</p>
<blockquote>
<div class="highlight"><pre><span class="cm">/* Future-safe accessor for struct mm_struct&#39;s cpu_vm_mask. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">cpumask_t</span> <span class="o">*</span><span class="nf">mm_cpumask</span><span class="p">(</span><span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">cpu_vm_mask_var</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</blockquote>
<ul class="simple">
<li><a class="reference external" href="https://en.wikipedia.org/wiki/Translation_lookaside_buffer">https://en.wikipedia.org/wiki/Translation_lookaside_buffer</a></li>
<li><a class="reference external" href="http://pages.cs.wisc.edu/~bart/537/lecturenotes/s17.html">http://pages.cs.wisc.edu/~bart/537/lecturenotes/s17.html</a></li>
</ul>
</div>
<div class="section" id="setup-command-line">
<h3>setup_command_line()</h3>
<blockquote>
<div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * We need to store the untouched command line for future reference.</span>
<span class="cm"> * We also need to store the touched command line since the parameter</span>
<span class="cm"> * parsing is performed in place, and we should allow a component to</span>
<span class="cm"> * store reference of name/value for future reference.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">setup_command_line</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">command_line</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">saved_command_line</span> <span class="o">=</span>
        <span class="n">memblock_virt_alloc</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">boot_command_line</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">initcall_command_line</span> <span class="o">=</span>
        <span class="n">memblock_virt_alloc</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">boot_command_line</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">static_command_line</span> <span class="o">=</span> <span class="n">memblock_virt_alloc</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">command_line</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">saved_command_line</span><span class="p">,</span> <span class="n">boot_command_line</span><span class="p">);</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">static_command_line</span><span class="p">,</span> <span class="n">command_line</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</blockquote>
<p>setup_command_line() 很單純，它先經由 memblock_virt_alloc() 配置記憶體，然後將
boot_command_line 和 command_line 拷貝到剛剛分配的記憶體存下來。</p>
<p>memblock 是一個簡單的記憶體管理機制，主要用於 Linux 核心啟動時，當完整的的記憶體管理架構尚未建立時，用來應付記憶體分配的需求。</p>
<ul class="simple">
<li><a class="reference external" href="https://0xax.gitbooks.io/linux-insides/content/mm/linux-mm-1.html">https://0xax.gitbooks.io/linux-insides/content/mm/linux-mm-1.html</a></li>
<li><a class="reference external" href="http://www.maxwellxxx.com/linuxmemblock">Linux 内核初期内存管理---memblock</a></li>
</ul>
</div>
<div class="section" id="setup-nr-cpu-ids">
<h3>setup_nr_cpu_ids()</h3>
<p>由 cpumask 最後一個 bit 的位置計算目前 CPU 的數目 (nr = number)。</p>
<blockquote>
<div class="highlight"><pre><span class="cm">/* An arch may set nr_cpu_ids earlier if needed, so this would be redundant */</span>
<span class="kt">void</span> <span class="n">__init</span> <span class="nf">setup_nr_cpu_ids</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">nr_cpu_ids</span> <span class="o">=</span> <span class="n">find_last_bit</span><span class="p">(</span><span class="n">cpumask_bits</span><span class="p">(</span><span class="n">cpu_possible_mask</span><span class="p">),</span><span class="n">NR_CPUS</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</blockquote>
</div>
<div class="section" id="setup-per-cpu-areas">
<h3>setup_per_cpu_areas()</h3>
<p>per-CPU area 顧名思義就是每個 CPU 專屬的記憶體區域。 setup_per_cpu_areas()
就是在為每個 CPU 配置它們個別專屬的記憶體區域。那為什麼要為每個 CPU 配置它們個別專屬的記憶體區域？</p>
<p>在 Linux 核心中有許多的計數器 (counter)，像網路封包的統計，一般最直覺的實作方式就是設置一個公共變數，收到封包時就加一，這個變數通常使用 int 型別，配合 atomic operation (原子操作)減少同步操作的開銷。
在單 CPU 的系統上 (uni-processor, UP)，這樣是很合理的設計，但在多 CPU 的系統上
(symmetric multiple processors，SMP)，這樣的設計會造成兩個問題:</p>
<ol class="arabic simple">
<li>atomic operation 需要把 memory 的特定區域或是 bus 鎖住，以免其他 CPU 干擾讀寫的動作。</li>
<li>由於這個變數常常被更動，所以 CPU 的 cache 常常需要被更新 (cache line bouncing)</li>
</ol>
<p>為了改善這兩個問題，Linux 核心使用 per-CPU variable 的設計。被宣告為 per-CPU variable
的變數會被配置在每個 CPU 的專屬的記憶體區域，每個 CPU 都只存取自已專屬的變數。以上面所提的網路封包計數的例子來說，每個 CPU 只計數自已看到的封包，當要知道封包計數時只需把每個 CPU 的計數加總起來。</p>
<p>這樣的設計減少了同步操作的要求，每個 CPU 各自有一份自已的變數資料，彼此之間互相不干擾；也因為 CPU 各自有擁有一份自已的資料，不會產生 cache line bouncing 影響 cache 的效率。</p>
<ul class="simple">
<li><a class="reference external" href="https://lwn.net/Articles/170003/">LWN: The search for fast, scalable counters</a></li>
<li><a class="reference external" href="https://lwn.net/Articles/258238/">LWN: Better per-CPU variables</a></li>
<li><a class="reference external" href="https://0xax.gitbooks.io/linux-insides/content/Concepts/per-cpu.html">Inside Linux: Per-CPU variables</a></li>
</ul>
</div>
<div class="section" id="build-all-zonelists">
<h3>build_all_zonelists()</h3>
<p>zonelist 代表了一個優先級序列，表示記憶體分配在 zone 中嘗試的順序，當目前的 zone 已無空的記憶體時，會從 zonelist 中找到下一個有可分配記憶體的 zone。build_all_zonelists() 負責設定 <a class="reference external" href="http://lxr.free-electrons.com/source/include/linux/mmzone.h?v=4.1#L706">pg_data_t</a> 中的 node_zonelists。</p>
<p>zonelist 的順序有 2 種選擇:</p>
<ul>
<li><p class="first">ZONELIST_ORDER_NODE : 以 node 為主排序，著重在 memory locality。</p>
<pre class="code literal-block">
e.g. node(0).ZONE_MOVABLE, node(0).ZONE_HIGHMEM, node(0).ZONE_NORMAL, node(0).ZONE_DMA,
     node(1).ZONE_MOVABLE, node(1).ZONE_HIGHMEM, node(1).ZONE_NORMAL, node(1).ZONE_DMA,
     ...
</pre>
</li>
<li><p class="first">ZONELIST_ORDER_ZONE : 以 zone 為主排序，優先尋找相同的型態 zone。</p>
<pre class="code literal-block">
e.g. node(0).ZONE_MOVABLE, node(1).ZONE_MOVABLE, ...,
     node(0).ZONE_HIGHMEM, node(1).ZONE_HIGHMEM, ...,
     node(0).ZONE_NORMAL, node(1).ZONE_NORMAL, ...,
     node(0).ZONE_DMA, node(1).ZONE_DMA, ...
</pre>
</li>
</ul>
<p>numa_zonelist_order 可以由 bootloader 傳給核心 (屬於 early_param)，或經由設定 /proc/sys/vm/numa_zonelist_order 動態改變 zonelist order。</p>
</div>
<div class="section" id="page-alloc-init">
<h3>page_alloc_init()</h3>
<p>page_alloc_init() 只是很單純地註冊一個關於 CPU 熱插拔事件處理的 callback function。由它所註冊的 page_alloc_cpu_notify() 來看，主要是關於 CPU 被動態移除後的相關處理。</p>
<blockquote>
<div class="highlight"><pre><span class="kt">void</span> <span class="n">__init</span> <span class="nf">page_alloc_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">hotcpu_notifier</span><span class="p">(</span><span class="n">page_alloc_cpu_notify</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<div class="highlight"><pre><span class="k">static</span> <span class="kt">int</span> <span class="nf">page_alloc_cpu_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">notifier_block</span> <span class="o">*</span><span class="n">self</span><span class="p">,</span>
                 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">action</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">hcpu</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">cpu</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">hcpu</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">==</span> <span class="n">CPU_DEAD</span> <span class="o">||</span> <span class="n">action</span> <span class="o">==</span> <span class="n">CPU_DEAD_FROZEN</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">lru_add_drain_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
        <span class="n">drain_pages</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

        <span class="cm">/*</span>
<span class="cm">         * Spill the event counters of the dead processor</span>
<span class="cm">         * into the current processors event counters.</span>
<span class="cm">         * This artificially elevates the count of the current</span>
<span class="cm">         * processor.</span>
<span class="cm">         */</span>
        <span class="n">vm_events_fold_cpu</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>

        <span class="cm">/*</span>
<span class="cm">         * Zero the differential counters of the dead processor</span>
<span class="cm">         * so that the vm statistics are consistent.</span>
<span class="cm">         *</span>
<span class="cm">         * This is only okay since the processor is dead and cannot</span>
<span class="cm">         * race with what we are doing.</span>
<span class="cm">         */</span>
        <span class="n">cpu_vm_stats_fold</span><span class="p">(</span><span class="n">cpu</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">NOTIFY_OK</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</blockquote>
</div>
</div>
<div class="section" id="reference">
<h2>Reference</h2>
<ul class="simple">
<li><a class="reference external" href="http://www.slideshare.net/shimosawa/linux-initialization-process-2">http://www.slideshare.net/shimosawa/linux-initialization-process-2</a></li>
<li><a class="reference external" href="https://0xax.gitbooks.io/linux-insides/content/Initialization/index.html">gitbook: Linux Insides: Kernel initialization process</a></li>
<li><a class="reference external" href="https://github.com/torvalds/linux/blame/v4.1/init/main.c#L492">init/main.c: start_kernel()</a> (git blame, 可以查看程式碼的改動記錄以及原因)</li>
</ul>
<p>Kernel Documentation:</p>
<ul class="simple">
<li>x86 boot protocol: <a class="reference external" href="https://www.kernel.org/doc/Documentation/x86/boot.txt">https://www.kernel.org/doc/Documentation/x86/boot.txt</a></li>
<li>arm booting: <a class="reference external" href="https://www.kernel.org/doc/Documentation/arm/Booting">https://www.kernel.org/doc/Documentation/arm/Booting</a></li>
</ul>
</div>
</div>
    <footer>
<p class="meta">
  <span class="byline author vcard">
    Posted by <span class="fn">
        Daniel Lin
    </span>
  </span>
<time datetime="2016-05-16T00:00:00+08:00" pubdate>2016-05-16, Mon</time>  <span class="categories">
    <a class='category' href='https://danielmaker.github.io/blog/category/linux.html'>Linux</a>
  </span>
  <span class="categories">
    <a class="category" href="https://danielmaker.github.io/blog/tag/linux-kernel.html">Linux kernel</a>  </span>
</p><div class="sharing">
</div>    </footer>
  </article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div>
  </section>
</div>
<aside class="sidebar">
  <section>
    <h1>Recent Posts</h1>
    <ul id="recent_posts">
      <li class="post">
          <a href="https://danielmaker.github.io/blog/linux/kernel_parameter_parsing.html">核心參數解析</a>
      </li>
      <li class="post">
          <a href="https://danielmaker.github.io/blog/linux/inside_start_kernel.html">深入淺出 start_kernel()</a>
      </li>
      <li class="post">
          <a href="https://danielmaker.github.io/blog/linux/start_kernel.html">核心的進入點: start_kernel()</a>
      </li>
      <li class="post">
          <a href="https://danielmaker.github.io/blog/linux/linux_kernel_beginning.html">Linux Kernel 探險地圖</a>
      </li>
      <li class="post">
          <a href="https://danielmaker.github.io/blog/about/may-the-source-be-with-you.html">May The Source Be With You</a>
      </li>
    </ul>
  </section>
  <section>

    <h1>Categories</h1>
    <ul id="recent_posts">
        <li><a href="https://danielmaker.github.io/blog/category/about.html">About</a></li>
        <li><a href="https://danielmaker.github.io/blog/category/linux.html">Linux</a></li>
    </ul>
  </section>

  <section>
  <h1>Tags</h1>
    <a href="https://danielmaker.github.io/blog/tag/linux-kernel.html">Linux kernel</a>  </section>




  <!-- Creative Commons 授權條款 -->
  <a target="_blank" class="svg" rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh_TW" style="display: inline-block;"
     title="姓名標示-非商業性-相同方式分享 4.0"><object alt="CreativeCommons: 姓名標示-非商業性-相同方式分享 4.0" data="https://danielmaker.github.io/blog/theme/images/by-nc-sa.svg" type="image/svg+xml" style="pointer-events: none;">/theme/images/by-nc-sa.svg</object></a>
  <!-- Creative Commons 授權條款 -->
</aside>    </div>
  </div>
  <footer role="contentinfo"><p>

  <a target="_blank" rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh_TW"
     title="姓名標示-非商業性-相同方式分享 4.0"><img alt="CreativeCommons: 姓名標示-非商業性-相同方式分享 4.0" src="https://danielmaker.github.io/blog/theme/images/cc-by-nc-sa-88x31.png" border="0" /></a>

    Copyright &copy;  2015&ndash;2016  Daniel Lin &mdash;

  <!-- Creative Commons 授權條款 -->
  本著作係採用
  <a target="_blank" rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh_TW"
     title="姓名標示-非商業性-相同方式分享 4.0">Creative Commons BY-NC-SA 條款</a> 授權.
  <!-- Creative Commons 授權條款 -->

  <span class="credit">Powered by <a href="http://getpelican.com">Pelican</a></span>
</p></footer>
  <script src="https://danielmaker.github.io/blog/theme/js/modernizr-2.0.js"></script>
  <script src="https://danielmaker.github.io/blog/theme/js/ender.js"></script>
  <script src="https://danielmaker.github.io/blog/theme/js/octopress.js" type="text/javascript"></script>
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-71811903-1', 'auto');

    ga('send', 'pageview');
    </script>
  <script type="text/javascript">
    var disqus_shortname = 'danielmaker';
    var disqus_identifier = '/linux/inside_start_kernel.html';
    var disqus_url = 'https://danielmaker.github.io/blog/linux/inside_start_kernel.html';
    var disqus_title = '深入淺出 start_kernel()';
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = "//" + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
     })();
  </script>
</body>
</html>