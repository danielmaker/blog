<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>List, HList, and Hash Table &mdash; Daniel Jslin</title>
  <meta name="author" content="Daniel Lin">

  <link href="https://danielmaker.github.io/blog/feeds/atom.xml" type="application/atom+xml" rel="alternate"
        title="Daniel Jslin Atom Feed" />
  <link href="https://danielmaker.github.io/blog/feeds/rss.xml" type="application/rss+xml" rel="alternate"
        title="Daniel Jslin RSS Feed" />





  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">


    <link href="https://danielmaker.github.io/blog/favicon.png" rel="icon">

  <link href="https://danielmaker.github.io/blog/theme/css/main.css" media="screen, projection"
        rel="stylesheet" type="text/css">

  <link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic"
        rel="stylesheet" type="text/css">
  <link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic"
        rel="stylesheet" type="text/css">
</head>

<body>
  <header role="banner"><hgroup>
  <h1><a href="https://danielmaker.github.io/blog/">Daniel Jslin</a></h1>
    <h2>May the source be with you</h2>
</hgroup></header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="https://danielmaker.github.io/blog/feeds/atom.xml" rel="subscribe-atom">Atom</a></li>
  <li><a href="https://danielmaker.github.io/blog/feeds/rss.xml" rel="subscribe-rss">RSS</a></li>
</ul>

<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="danielmaker.github.io/blog">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>

<ul class="main-navigation">
      <li >
        <a href="https://danielmaker.github.io/blog/category/about.html">About</a>
      </li>
      <li class="active">
        <a href="https://danielmaker.github.io/blog/category/linux.html">Linux</a>
      </li>
</ul></nav>
  <div id="main">
    <div id="content">
<div>
  <article class="hentry" role="article">
<header>
      <h1 class="entry-title">List, HList, and Hash Table</h1>
    <p class="meta">
<time datetime="2016-11-20T00:00:00+08:00" pubdate>2016-11-20, Sun</time>    </p>
</header>

  <div class="entry-content"><div class="section" id="list">
<h2>List</h2>
<p>List 可以說是 Linux kernel 中最基礎的資料結構，它的定義如下 (<a class="reference external" href="http://lxr.free-electrons.com/source/include/linux/types.h?v=4.1#L177">include/linux/types.h</a>):</p>
<blockquote>
<pre class="code literal-block">
struct list_head {
    struct list_head *next, *prev;
};
</pre>
<object data="images/list.svg" type="image/svg+xml">
</object>
</blockquote>
<p>List 的操作定義在: <a class="reference external" href="http://lxr.free-electrons.com/source/include/linux/list.h?v=4.1">include/linux/list.h</a></p>
<ul class="simple">
<li>list_empty(head) - tests whether a list is empty</li>
<li>list_add(new_entry, head) - adds a new entry. Insert a new entry after the specified head.</li>
<li>list_del(entry) - deletes entry from list.</li>
<li>list_for_each(pos, head) - iterate over a list</li>
</ul>
<p>這個 list 結構有幾個特點:</p>
<ol class="arabic">
<li><p class="first">它是一個循環的雙向鏈結，沒有特定的&quot;頭&quot;和&quot;尾&quot;節點，每個節點都是可以是&quot;頭&quot;或是&quot;尾&quot;。
這是一個非常優雅的設計，沒有&quot;頭&quot;和&quot;尾&quot;的特例，新增節點時只要將前一個節點的 next 指標和後面的節點的 prev 指標指向新節點，然後將新節點的 prev 和 next 指標各別指向前後節點 (為了方便說明，下面的程式碼和 kernel 有些許不同):</p>
<pre class="code literal-block">
void __list_add(struct list_head *new_node,
                struct list_head *prev,
                struct list_head *next)
{
    prev-&gt;next = new_node;
    next-&gt;prev = new_node;
    new_node-&gt;prev = prev;
    new_node-&gt;next = next;
}
</pre>
<p>移除節點時，只需把前節點的 next 指向後節點，後節點的 prev 指向前節點:</p>
<pre class="code literal-block">
void __list_del(struct list_head * prev, struct list_head * next)
{
    prev-&gt;next = next;
    next-&gt;prev = prev;
}

// list_del - deletes entry from list
void list_del(struct list_head *entry)
{
    __list_del(entry-&gt;prev, entry-&gt;next);
}
</pre>
<p>這樣完全不需要特別檢查是不是&quot;頭&quot;或&quot;尾&quot;節點，程式碼看起來非常優雅。
要注意的是，從 list 中移除節點不包含釋放節點所佔的記憶體。</p>
</li>
</ol>
<!--  -->
<ol class="arabic" start="2">
<li><p class="first">只要一直順著 next 指標就可以將整個 list 走訪一遍。
(由 head-&gt;next 開始，當 pos 指回到 head 時停止尋訪)</p>
<pre class="code literal-block">
/**
 * list_for_each  - iterate over a list
 * &#64;pos:  the &amp;struct list_head to use as a loop cursor.
 * &#64;head: the head for your list.
 */
#define list_for_each(pos, head) \
  for (pos = (head)-&gt;next; pos != (head); pos = pos-&gt;next)
</pre>
</li>
<li><p class="first">這是一個泛化 (generic) 的設計，任何 struct 只要將 list_head 加入它的欄位中，這個 struct
就可以變成鏈結串列的節點。第一眼看到這個設計可能會覺得有點納悶，這跟我們在資料結構教科書上看到的鏈結串列設計不同。我們比較熟悉的鏈結串列結構應該像是這樣子:</p>
<pre class="code literal-block">
struct file_system_type {
    const char* name;

    struct file_system_type* next; /* next file_system_type in list */
}

有一個相同資料結構的 next 指標指向下一個節點。
</pre>
</li>
</ol>
<blockquote>
<p>這樣的說明有點抽象，讓我們實際來看一個例子:</p>
<p>在下面的例子中，struct object 有一個 list_head 型態的成員: node</p>
<div class="highlight"><pre><span class="k">struct</span> <span class="n">object</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">node</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
<div class="highlight"><pre><span class="kt">void</span> <span class="nf">list_add_example</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">obj_list</span><span class="p">);</span> <span class="c1">// declare a list head</span>

    <span class="k">struct</span> <span class="n">object</span> <span class="n">obj1</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;obj1&quot;</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj1</span><span class="p">.</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">obj_list</span><span class="p">);</span> <span class="c1">// add a new entry after obj_list</span>

    <span class="k">struct</span> <span class="n">object</span> <span class="n">obj2</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;obj2&quot;</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj2</span><span class="p">.</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">obj_list</span><span class="p">);</span> <span class="c1">// add a new entry after obj_list</span>

    <span class="k">struct</span> <span class="n">object</span> <span class="n">obj3</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
        <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;obj3&quot;</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obj3</span><span class="p">.</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">obj_list</span><span class="p">);</span> <span class="c1">// add a new entry after obj_list</span>
<span class="p">}</span>
</pre></div>
<p>在經過上面的操作之後，這個 list 會變成下面這個樣子:</p>
<object data="images/obj_list.svg" type="image/svg+xml">
</object>
<p>struct object 實際上是由 list_head 串起來。</p>
<p>利用 list_for_each 來走訪整個鏈結串列:</p>
<div class="highlight"><pre><span class="k">struct</span> <span class="n">list_head</span><span class="o">*</span> <span class="n">iter</span><span class="p">;</span>
<span class="n">list_for_each</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">obj_list</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">object</span><span class="o">*</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">iter</span><span class="p">,</span> <span class="k">struct</span> <span class="n">object</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>輸出結果:</p>
<pre class="code literal-block">
obj3
obj2
obj1
</pre>
<p>上面程式碼的一個重點在於利用 list_entry() 取得實體 struct object 的位址，而 list_entry() 實際上是由 container_of() 這個 macro 實現。</p>
<pre class="code literal-block">
/**
 * list_entry - get the struct for this entry
 * &#64;ptr:  the &amp;struct list_head pointer.
 * &#64;type: the type of the struct this is embedded in.
 * &#64;member: the name of the list_head within the struct.
 */
#define list_entry(ptr, type, member) \
    container_of(ptr, type, member)
</pre>
</blockquote>
</div>
<div class="section" id="container-of">
<h2>container_of()</h2>
<p>我們已知 struct object 的成員 node 的記憶體位址，那如果我們也知道成員 node 在 struct object
裡的偏移量(offset)，這樣我們是不是可以推算出這個 struct object 結構體的位址？只要將成員 node 的位址依照偏移量往回推就可以得到 struct object 結構體的位址。</p>
<p>這個偏移量的推算可以由 offsetof() 這個 macro 完成:</p>
<blockquote>
<p><a class="reference external" href="http://man7.org/linux/man-pages/man3/offsetof.3.html">http://man7.org/linux/man-pages/man3/offsetof.3.html</a></p>
<pre class="code literal-block">
#undef offsetof
#ifdef __compiler_offsetof
#define offsetof(TYPE, MEMBER) __compiler_offsetof(TYPE, MEMBER)
#else
#define offsetof(TYPE, MEMBER) ((size_t) &amp;((TYPE *)0)-&gt;MEMBER)
#endif
</pre>
</blockquote>
<p>container_of() 這個神奇的 macro 就是利用 offsetof() 推算外部結構體的起始位址。
以上面的例子來說，相對成員變數 node 而言，struct object 是它的容器(container)，container of node 就是 struct object。</p>
<blockquote>
<pre class="code literal-block">
/**
 * container_of - cast a member of a structure out to the containing structure
 * &#64;ptr:    the pointer to the member.
 * &#64;type:   the type of the container struct this is embedded in.
 * &#64;member: the name of the member within the struct.
 */
#define container_of(ptr, type, member) ({                 \
    const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);   \
    (type *)( (char *)__mptr - offsetof(type, member) );})
</pre>
<p>struct object* obj = container_of(ptr, struct object, node);</p>
<object data="images/container_of.svg" type="image/svg+xml">
</object>
<p>上面的示意圖假設 struct object 沒有經過任何的 padding 及 alignment。我們知道成員 node 的位址 ptr 的值，偏移量是 20，struct object* obj 的位址可以很簡單的由
ptr - 20 = addr 來求得。 推薦閱讀: <a class="reference external" href="http://radek.io/2012/11/10/magical-container_of-macro/">The Magical container_of() Macro</a></p>
</blockquote>
</div>
<div class="section" id="hlist-and-hashtable">
<h2>HList and Hashtable</h2>
<p>HList 用於 hash table 的實作，它的資料結構定義在 <a class="reference external" href="http://lxr.free-electrons.com/source/include/linux/types.h?v=4.1#L177">include/linux/types.h</a> 之中:</p>
<blockquote>
<pre class="code literal-block">
struct hlist_head {
    struct hlist_node *first;
};

struct hlist_node {
    struct hlist_node *next, **pprev;
};
</pre>
<object data="images/hashtable.svg" type="image/svg+xml">
</object>
</blockquote>
<ul>
<li><p class="first">HList 的操作與 List 一樣定義在: <a class="reference external" href="http://lxr.free-electrons.com/source/include/linux/list.h?v=4.1">include/linux/list.h</a> ，以 hlist_ 開頭</p>
</li>
<li><p class="first">hlist_head 和 hlist_node 用於 hash table 中 bucket 的實作，具有相同 hash value 的節點會放在同一條 hlist 中。
為了節省空間，hlist_head 只使用一個 first 指標指向 hlist_node，沒有指向串列尾節點的指標。</p>
</li>
<li><p class="first">hlist_node 有兩個指標，但是需要注意的是 pprev 是指標的指標，它指向的是前一個節點的 next 指標。
這樣的好處是即使要刪除的節點是&quot;最前頭的節點&quot;時，也可以通過 *pprev = next 直接修改指標的指向。</p>
<pre class="code literal-block">
// deletes entry from hlist
void __hlist_del(struct hlist_node* entry)
{
    struct hlist_node *next = entry-&gt;next;
    struct hlist_node **pprev = entry-&gt;pprev;
    *pprev = next;
    if (next)
      next-&gt;pprev = pprev;
}
</pre>
</li>
<li><p class="first">在 Linux kernel 3.7 之後採用由 Sasha Levin 實作的通用型 hash table (<a class="reference external" href="https://lwn.net/Articles/510202/">LWN: A generic hash table</a>)，使用 DEFINE_HASHTABLE(name, bits) 的 macro 來宣告 hash table:</p>
<ul class="simple">
<li>name: the name of the hash table</li>
<li>bits: the number of bits of hash values</li>
</ul>
<p>第二的參數 bits 比較特別，它代表的是 hash value 的有效位元數。若 bits = 3，hash value 的範團會是 0~7，若 bits = 10，hash value 的範團會是 0 ~ 1023。前者需要準備 8 個 buckets，後者則需要 1024 個 buckets，bits 參數會決定 hash table 的 buckets 的數量 (=2 <sup>bits</sup>)。hashtable 實作上會以 hlist_head array 的方式來配置。</p>
<p>舉例來說， DEFINE_HASHTABLE(htable, 3) 會展開成:</p>
<pre class="code literal-block">
struct hlist_head htable[8] = { [0 ... 7] = HLIST_HEAD_INIT };
</pre>
<p>這是一個有 8 個 buckets 的 hash table。
(初始化的語法請參照 <a class="reference external" href="https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html">GCC Designated Initializers</a>)</p>
<p>經由 hash function 將值映射到這 8 個 buckets 中，當衝突發生時，直接加到 hlist_head 後的串列中。</p>
</li>
<li><p class="first">hash table 相關的操作定義在 <a class="reference external" href="http://lxr.free-electrons.com/source/include/linux/hashtable.h?v=4.1">include/linux/hashtable.h</a></p>
<ul class="simple">
<li>hash_init - initialize a hash table</li>
<li>hash_empty - check whether a hashtable is empty</li>
<li>hash_add - add an object to a hashtable</li>
<li>hash_del - remove an object from a hashtable</li>
<li>hash_for_each - iterate over a hashtable</li>
<li>hash_for_each_possible - iterate over all possible objects hashing to the same bucket</li>
</ul>
</li>
<li><p class="first">hashtable 預設的 hash function 定義在 <a class="reference external" href="http://lxr.free-electrons.com/source/include/linux/hash.h?v=4.1">include/linux/hash.h</a> ，有 32 和 64 兩個版本，如下:</p>
<div class="highlight"><pre><span class="cm">/* 2^31 + 2^29 - 2^25 + 2^22 - 2^19 - 2^16 + 1 */</span>
<span class="cp">#define GOLDEN_RATIO_PRIME_32 0x9e370001UL</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u32</span> <span class="nf">hash_32</span><span class="p">(</span><span class="n">u32</span> <span class="n">val</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* On some cpus multiply is faster, on others gcc will do shifts */</span>
    <span class="n">u32</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">val</span> <span class="o">*</span> <span class="n">GOLDEN_RATIO_PRIME_32</span><span class="p">;</span>

    <span class="cm">/* High bits are more random, so use them. */</span>
    <span class="k">return</span> <span class="n">hash</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">32</span> <span class="o">-</span> <span class="n">bits</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<div class="highlight"><pre><span class="cm">/*  2^63 + 2^61 - 2^57 + 2^54 - 2^51 - 2^18 + 1 */</span>
<span class="cp">#define GOLDEN_RATIO_PRIME_64 0x9e37fffffffc0001UL</span>

<span class="k">static</span> <span class="n">__always_inline</span> <span class="n">u64</span> <span class="nf">hash_64</span><span class="p">(</span><span class="n">u64</span> <span class="n">val</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">u64</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>

<span class="cp">#if defined(CONFIG_ARCH_HAS_FAST_MULTIPLIER) &amp;&amp; BITS_PER_LONG == 64</span>
    <span class="n">hash</span> <span class="o">=</span> <span class="n">hash</span> <span class="o">*</span> <span class="n">GOLDEN_RATIO_PRIME_64</span><span class="p">;</span>
<span class="cp">#else</span>
    <span class="cm">/*  Sigh, gcc can&#39;t optimise this alone like it does for 32 bits. */</span>
    <span class="n">u64</span> <span class="n">n</span> <span class="o">=</span> <span class="n">hash</span><span class="p">;</span>
    <span class="n">n</span> <span class="o">&lt;&lt;=</span> <span class="mi">18</span><span class="p">;</span>
    <span class="n">hash</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">n</span> <span class="o">&lt;&lt;=</span> <span class="mi">33</span><span class="p">;</span>
    <span class="n">hash</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">n</span> <span class="o">&lt;&lt;=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">hash</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">n</span> <span class="o">&lt;&lt;=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">hash</span> <span class="o">-=</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">n</span> <span class="o">&lt;&lt;=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="n">hash</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
    <span class="n">n</span> <span class="o">&lt;&lt;=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">hash</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
<span class="cp">#endif</span>

    <span class="cm">/* High bits are more random, so use them. */</span>
    <span class="k">return</span> <span class="n">hash</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">64</span> <span class="o">-</span> <span class="n">bits</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</li>
</ul>
<div class="section" id="hashtable-example">
<h3>Hashtable example:</h3>
<p>下面用例子來說明 hashtable 的使用，將上面 list 例子中的 struct object 改成 hlist 的版本:</p>
<blockquote>
<div class="highlight"><pre><span class="k">struct</span> <span class="n">object</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>

    <span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">node</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
<div class="highlight"><pre><span class="kt">void</span> <span class="nf">hashtable_example</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// define a hash table with 2^3(=8) buckets</span>
    <span class="n">DEFINE_HASHTABLE</span><span class="p">(</span><span class="n">htable</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
    <span class="c1">// =&gt; struct hlist_head htable[8] = { [0 ... 7] = HLIST_HEAD_INIT };</span>

    <span class="k">struct</span> <span class="n">object</span> <span class="n">obj1</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;obj1&quot;</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="n">hash_add</span><span class="p">(</span><span class="n">htable</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">obj1</span><span class="p">.</span><span class="n">node</span><span class="p">,</span> <span class="n">obj1</span><span class="p">.</span><span class="n">id</span><span class="p">);</span>

    <span class="k">struct</span> <span class="n">object</span> <span class="n">obj2</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;obj2&quot;</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="n">hash_add</span><span class="p">(</span><span class="n">htable</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">obj2</span><span class="p">.</span><span class="n">node</span><span class="p">,</span> <span class="n">obj2</span><span class="p">.</span><span class="n">id</span><span class="p">);</span>

    <span class="k">struct</span> <span class="n">object</span> <span class="n">obj3</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
        <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;obj3&quot;</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="n">hash_add</span><span class="p">(</span><span class="n">htable</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">obj3</span><span class="p">.</span><span class="n">node</span><span class="p">,</span> <span class="n">obj3</span><span class="p">.</span><span class="n">id</span><span class="p">);</span>

    <span class="k">struct</span> <span class="n">object</span> <span class="n">obj9</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">.</span><span class="n">id</span> <span class="o">=</span> <span class="mi">9</span><span class="p">,</span>
        <span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;obj9&quot;</span><span class="p">,</span>
    <span class="p">};</span>
    <span class="n">hash_add</span><span class="p">(</span><span class="n">htable</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">obj9</span><span class="p">.</span><span class="n">node</span><span class="p">,</span> <span class="n">obj9</span><span class="p">.</span><span class="n">id</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
<p>經過上面的操作之後，hash table 呈現如下:</p>
<ul class="simple">
<li>obj1 和 obj9 的 hash value 衝突，放入同一個 bucket 的串列中</li>
</ul>
<object data="images/hashtable_example.svg" type="image/svg+xml">
</object>
<p>以 hash_for_each_possible() 尋訪 bucket 內所有的節點(hlist_node)，因為 hash value
可能會有衝突的關係，同一個 bucket 內可能會有不同 key value 的節點，所以需要檢查是不是要查找的
key value。</p>
<div class="highlight"><pre><span class="kt">int</span> <span class="n">key</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">object</span><span class="o">*</span> <span class="n">obj</span><span class="p">;</span>
<span class="n">hash_for_each_possible</span><span class="p">(</span><span class="n">htable</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">obj</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">==</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;key=%d =&gt; %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">obj</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</blockquote>
</div>
</div>
<div class="section" id="id1">
<h2>小結</h2>
<p>List, HList and hashtable 是 Linux kernel 中常見的資料結構，它們的設計是經過高手長時間淬煉過的精華，但因為它們的實作及使用方式和我們常見的設計不同，對初次接觸 Linux kernel 的新手肯定會覺得相當的困惑，在了解之後，又會非常佩服 kernel hackers 在設計上的巧思。它們被設計的十分優雅，高效又易於使用。</p>
<div class="section" id="id2">
<h3>範例程式</h3>
<p>上面的範例程式可以在下面的 github 連結找到:</p>
<p><a class="reference external" href="https://github.com/danielmaker/linux_study/tree/master/list_example">https://github.com/danielmaker/linux_study/tree/master/list_example</a></p>
</div>
</div>
<div class="section" id="reference">
<h2>Reference</h2>
<ul class="simple">
<li><a class="reference external" href="http://adrianhuang.blogspot.tw/2007/10/linux-kernel-listhead.html">Adrian: Linux Kernel: 強大又好用的 list_head 結構</a></li>
<li><a class="reference external" href="http://nano-chicken.blogspot.tw/2009/09/linux-hlist.html">Nano 雞排: linux hlist</a></li>
</ul>
<!--  -->
<ul class="simple">
<li><a class="reference external" href="http://adrianhuang.blogspot.tw/2010/01/linux-kernel-containerof.html">Adrian: Linux Kernel: container_of 巨集</a></li>
<li><a class="reference external" href="http://radek.io/2012/11/10/magical-container_of-macro/">The Magical container_of() Macro</a></li>
<li><a class="reference external" href="http://stackoverflow.com/questions/6083734/rationale-behind-the-container-of-macro-in-linux-list-h">stackoverlow: Rationale behind the container_of macro</a></li>
<li><a class="reference external" href="http://blog.linux.org.tw/~jserv/archives/001399.html">Jserv's blog: C99 的 offsetof macro</a></li>
</ul>
<!--  -->
<ul class="simple">
<li><a class="reference external" href="https://lwn.net/Articles/510202/">LWN: A generic hash table</a></li>
<li><a class="reference external" href="http://stackoverflow.com/questions/5489025/hash-table-in-linux-kernel">stackoverlow: Hash table in Linux kernel</a></li>
<li><a class="reference external" href="https://kernelnewbies.org/FAQ/Hashtables">Kernel Newbies: How does the kernel implements Hashtables?</a></li>
</ul>
<!--  -->
<ul class="simple">
<li><a class="reference external" href="https://gcc.gnu.org/onlinedocs/gcc/Designated-Inits.html">GCC Designated Initializers</a></li>
<li><a class="reference external" href="https://www.reddit.com/r/HandmadeQuake/comments/4d6993/linus_torvaldss_double_pointer_problem/">Linus Torvalds's Double Pointer Problem</a></li>
</ul>
</div>
</div>
    <footer>
<p class="meta">
  <span class="byline author vcard">
    Posted by <span class="fn">
        Daniel Lin
    </span>
  </span>
<time datetime="2016-11-20T00:00:00+08:00" pubdate>2016-11-20, Sun</time>  <span class="categories">
    <a class='category' href='https://danielmaker.github.io/blog/category/linux.html'>Linux</a>
  </span>
  <span class="categories">
    <a class="category" href="https://danielmaker.github.io/blog/tag/linux-kernel.html">Linux kernel</a>  </span>
</p><div class="sharing">
</div>    </footer>
  </article>

  <section>
    <h1>Comments</h1>
    <div id="disqus_thread" aria-live="polite"><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div>
  </section>
</div>
<aside class="sidebar">
  <section>
    <h1>Recent Posts</h1>
    <ul id="recent_posts">
      <li class="post">
          <a href="https://danielmaker.github.io/blog/linux/list_hlist_hashtable.html">List, HList, and Hash Table</a>
      </li>
      <li class="post">
          <a href="https://danielmaker.github.io/blog/linux/kernel_parameter_parsing.html">核心參數解析</a>
      </li>
      <li class="post">
          <a href="https://danielmaker.github.io/blog/linux/inside_start_kernel.html">深入淺出 start_kernel()</a>
      </li>
      <li class="post">
          <a href="https://danielmaker.github.io/blog/linux/start_kernel.html">核心的進入點: start_kernel()</a>
      </li>
      <li class="post">
          <a href="https://danielmaker.github.io/blog/linux/linux_kernel_beginning.html">Linux Kernel 探險地圖</a>
      </li>
    </ul>
  </section>
  <section>

    <h1>Categories</h1>
    <ul id="recent_posts">
        <li><a href="https://danielmaker.github.io/blog/category/about.html">About</a></li>
        <li><a href="https://danielmaker.github.io/blog/category/linux.html">Linux</a></li>
    </ul>
  </section>

  <section>
  <h1>Tags</h1>
    <a href="https://danielmaker.github.io/blog/tag/linux-kernel.html">Linux kernel</a>  </section>




  <!-- Creative Commons 授權條款 -->
  <a target="_blank" class="svg" rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh_TW" style="display: inline-block;"
     title="姓名標示-非商業性-相同方式分享 4.0"><object alt="CreativeCommons: 姓名標示-非商業性-相同方式分享 4.0" data="https://danielmaker.github.io/blog/theme/images/by-nc-sa.svg" type="image/svg+xml" style="pointer-events: none;">/theme/images/by-nc-sa.svg</object></a>
  <!-- Creative Commons 授權條款 -->
</aside>    </div>
  </div>
  <footer role="contentinfo"><p>

  <a target="_blank" rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh_TW"
     title="姓名標示-非商業性-相同方式分享 4.0"><img alt="CreativeCommons: 姓名標示-非商業性-相同方式分享 4.0" src="https://danielmaker.github.io/blog/theme/images/cc-by-nc-sa-88x31.png" border="0" /></a>

    Copyright &copy;  2015&ndash;2016  Daniel Lin &mdash;

  <!-- Creative Commons 授權條款 -->
  本著作係採用
  <a target="_blank" rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh_TW"
     title="姓名標示-非商業性-相同方式分享 4.0">Creative Commons BY-NC-SA 條款</a> 授權.
  <!-- Creative Commons 授權條款 -->

  <span class="credit">Powered by <a href="http://getpelican.com">Pelican</a></span>
</p></footer>
  <script src="https://danielmaker.github.io/blog/theme/js/modernizr-2.0.js"></script>
  <script src="https://danielmaker.github.io/blog/theme/js/ender.js"></script>
  <script src="https://danielmaker.github.io/blog/theme/js/octopress.js" type="text/javascript"></script>
    <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-71811903-1', 'auto');

    ga('send', 'pageview');
    </script>
  <script type="text/javascript">
    var disqus_shortname = 'danielmaker';
    var disqus_identifier = '/linux/list_hlist_hashtable.html';
    var disqus_url = 'https://danielmaker.github.io/blog/linux/list_hlist_hashtable.html';
    var disqus_title = 'List, HList, and Hash Table';
    (function() {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = "//" + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
     })();
  </script>
</body>
</html>