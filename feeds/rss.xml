<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Daniel Jslin</title><link>https://danielmaker.github.io/blog/</link><description>May the source be with you</description><atom:link href="https://danielmaker.github.io/blog/feeds/rss.xml" rel="self"></atom:link><lastBuildDate>Sat, 13 Aug 2016 00:00:00 +0800</lastBuildDate><item><title>核心參數解析</title><link>https://danielmaker.github.io/blog/linux/kernel_parameter_parsing.html</link><description>&lt;!-- ............................................................................. --&gt;
&lt;style type="text/css"&gt;
    .red    { color: red;   }
    .blue   { color: blue;  }
    .red-b  { color: red;  font-weight: bold; }
    .blue-b { color: blue; font-weight: bold; }
    .green  { color: green;  }
    .gray   { color: gray;  }
    .diagram {line-height: 1;}
&lt;/style&gt;&lt;!-- ............................................................................. --&gt;
&lt;p&gt;Linux 核心啟動時會解析由 bootloader 傳來的參數，來設定核心運作時的行為。&lt;/p&gt;
&lt;p&gt;傳給核心的參數是以空格分隔的字串，通常的型式如下:&lt;/p&gt;
&lt;blockquote&gt;
param[=value_1][,value_2]...[,value_10]&lt;/blockquote&gt;
&lt;p&gt;&amp;quot;param&amp;quot; 是關鍵字，後面跟著設定值，以逗號分隔。一個關鍵字後面最多可以有 10 個值，但是可以透過再次使用同一關鍵字的方式，傳遞超過 10 個以上的參數。&lt;/p&gt;
&lt;p&gt;舉例來說，bootloader 可以透過 &amp;quot;init=...&amp;quot; 指定系統初始化的程序；或是透過 &amp;quot;root=...&amp;quot;
指定 root filesystem device，如: &amp;quot;root=/dev/hda3&amp;quot;。&lt;/p&gt;
&lt;p&gt;這個由 bootloader 傳給核心的參數字串也可以包含傳給 init 程序的參數，核心只會解析到 &amp;quot;--&amp;quot;
之前的字串，在 &amp;quot;--&amp;quot; 之後的字串會被當成傳給 init 程序的參數。&lt;/p&gt;
&lt;p&gt;詳細的核心參數說明，請參考下面兩份文件:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://man7.org/linux/man-pages/man7/bootparam.7.html"&gt;http://man7.org/linux/man-pages/man7/bootparam.7.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.kernel.org/doc/Documentation/kernel-parameters.txt"&gt;https://www.kernel.org/doc/Documentation/kernel-parameters.txt&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Linux 核心跟據不同的架構對 bootloader 有不同的要求。以 x86 架構來說，核心會需要 bootloader 將
&lt;a class="reference external" href="http://lxr.free-electrons.com/source/arch/x86/include/uapi/asm/bootparam.h?v=4.1#L113"&gt;struct boot_params&lt;/a&gt; 的資料準備好，然後在核心啟動時傳給核心。核心參數字串就是包含在其中的
&lt;a class="reference external" href="http://lxr.free-electrons.com/source/arch/x86/include/uapi/asm/bootparam.h?v=4.1#L48"&gt;struct setup_header&lt;/a&gt; 結構內的 cmd_line_ptr。&lt;/p&gt;
&lt;blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;setup_header&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;__u8&lt;/span&gt;    &lt;span class="n"&gt;setup_sects&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;__u16&lt;/span&gt;   &lt;span class="n"&gt;root_flags&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;__u32&lt;/span&gt;   &lt;span class="n"&gt;syssize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;__u16&lt;/span&gt;   &lt;span class="n"&gt;ram_size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;omitted&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;

&lt;span class="hll"&gt;    &lt;span class="n"&gt;__u32&lt;/span&gt;   &lt;span class="n"&gt;cmd_line_ptr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;    &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;omitted&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="n"&gt;__u32&lt;/span&gt;   &lt;span class="n"&gt;cmdline_size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;omitted&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;__attribute__&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;packed&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;boot_params&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;screen_info&lt;/span&gt; &lt;span class="n"&gt;screen_info&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="cm"&gt;/* 0x000 */&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;apm_bios_info&lt;/span&gt; &lt;span class="n"&gt;apm_bios_info&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="cm"&gt;/* 0x040 */&lt;/span&gt;
    &lt;span class="n"&gt;__u8&lt;/span&gt;  &lt;span class="n"&gt;_pad2&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;                             &lt;span class="cm"&gt;/* 0x054 */&lt;/span&gt;

    &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;omitted&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;

&lt;span class="hll"&gt;    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;setup_header&lt;/span&gt; &lt;span class="n"&gt;hdr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="cm"&gt;/* setup header */&lt;/span&gt;  &lt;span class="cm"&gt;/* 0x1f1 */&lt;/span&gt;
&lt;/span&gt;    &lt;span class="n"&gt;__u8&lt;/span&gt;  &lt;span class="n"&gt;_pad7&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mh"&gt;0x290&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mh"&gt;0x1f1&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;setup_header&lt;/span&gt;&lt;span class="p"&gt;)];&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;omitted&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;__attribute__&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;packed&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;p&gt;ARM 架構則是要求 bootloader 以 &lt;a class="reference external" href="http://lxr.free-electrons.com/source/arch/arm/include/uapi/asm/setup.h?v=4.1#L146"&gt;struct tag&lt;/a&gt; 格式將資料傳給核心。&lt;/p&gt;
&lt;blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;tag&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;tag_header&lt;/span&gt; &lt;span class="n"&gt;hdr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;union&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;tag_core&lt;/span&gt;     &lt;span class="n"&gt;core&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;tag_mem32&lt;/span&gt;    &lt;span class="n"&gt;mem&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;tag_videotext&lt;/span&gt;    &lt;span class="n"&gt;videotext&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;tag_ramdisk&lt;/span&gt;  &lt;span class="n"&gt;ramdisk&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;tag_initrd&lt;/span&gt;   &lt;span class="n"&gt;initrd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;tag_serialnr&lt;/span&gt; &lt;span class="n"&gt;serialnr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;tag_revision&lt;/span&gt; &lt;span class="n"&gt;revision&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;tag_videolfb&lt;/span&gt; &lt;span class="n"&gt;videolfb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="hll"&gt;        &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;tag_cmdline&lt;/span&gt;  &lt;span class="n"&gt;cmdline&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;
        &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;omitted&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;p&gt;核心會在 &lt;a class="reference external" href="http://lxr.free-electrons.com/source/init/main.c?v=4.1#L492"&gt;start_kernel()&lt;/a&gt; 內對傳到核心的參數字串進行解析。主要會分為兩個階段，分別由 &lt;a class="reference external" href="http://lxr.free-electrons.com/source/init/main.c?v=4.1#L436"&gt;parse_early_param()&lt;/a&gt; 及 &lt;a class="reference external" href="http://lxr.free-electrons.com/source/kernel/params.c?v=4.1#L191"&gt;parse_args()&lt;/a&gt; 這兩個函式進行解析。&lt;/p&gt;
&lt;blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;asmlinkage&lt;/span&gt; &lt;span class="n"&gt;__visible&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;__init&lt;/span&gt; &lt;span class="nf"&gt;start_kernel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;command_line&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// a pointer to the kernel command line&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;after_dashes&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;omitted&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;

    &lt;span class="n"&gt;setup_arch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;command_line&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;        &lt;span class="c1"&gt;// architecture-specific setup&lt;/span&gt;

    &lt;span class="n"&gt;setup_command_line&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;command_line&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// store the untouched command line&lt;/span&gt;

    &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;omitted&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;


    &lt;span class="n"&gt;pr_notice&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Kernel command line: %s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;boot_command_line&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;parse_early_param&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;                         &lt;span class="c1"&gt;// parse options for early_param()&lt;/span&gt;
    &lt;span class="n"&gt;after_dashes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parse_args&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Booting kernel&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  &lt;span class="c1"&gt;// parse options for module_param(), module_param_named(), core_param()&lt;/span&gt;
                  &lt;span class="n"&gt;static_command_line&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;__start___param&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                  &lt;span class="n"&gt;__stop___param&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;__start___param&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;unknown_bootoption&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;// parse options for __setup()&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;IS_ERR_OR_NULL&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;after_dashes&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="n"&gt;parse_args&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Setting init args&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;after_dashes&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  &lt;span class="c1"&gt;// after_dashes will be passed to the init process as argv&lt;/span&gt;
               &lt;span class="n"&gt;set_init_arg&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;omitted&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class="section" id="early-param"&gt;
&lt;h2&gt;early_param&lt;/h2&gt;
&lt;p&gt;有些參數有較高的優先權，需要先被處理，這類的參數被稱為 early_param。舉例來說，像 log level
的設定會影響訊息的輸出，若太晚生效的話，有些除錯訊息可能就不會被看到。&lt;/p&gt;
&lt;div class="section" id="early-option-example"&gt;
&lt;h3&gt;Early option example&lt;/h3&gt;
&lt;blockquote&gt;
&lt;pre class="code literal-block"&gt;
debug       [KNL] Enable kernel debugging (events log level).

quiet       [KNL] Disable most log messages

loglevel=   All Kernel Messages with a loglevel smaller than the
            console loglevel will be printed to the console. It can
            also be changed with klogd or other programs. The
            loglevels are defined as follows:

            0 (KERN_EMERG)      system is unusable
            1 (KERN_ALERT)      action must be taken immediately
            2 (KERN_CRIT)       critical conditions
            3 (KERN_ERR)        error conditions
            4 (KERN_WARNING)    warning conditions
            5 (KERN_NOTICE)     normal but significant condition
            6 (KERN_INFO)       informational
            7 (KERN_DEBUG)      debug-level messages
&lt;/pre&gt;
&lt;p&gt;以 &amp;quot;debug&amp;quot; 這個參數為例，它的功用是把 log level 設到 debug-level，允許更多的訊息輸出方便除錯。為了處理 &amp;quot;debug&amp;quot; 參數的設定，在核心內部定義了一個 debug_kernel() 函式負責處理 &amp;quot;debug&amp;quot; 參數的設定，然後利用 early_param() 這個 macro 將 &amp;quot;debug&amp;quot; 和處理函式 debug_kernel 關聯起來。&amp;quot;quiet&amp;quot; 參數也是一樣的處理方式。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;__init&lt;/span&gt; &lt;span class="nf"&gt;debug_kernel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;console_loglevel&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CONSOLE_LOGLEVEL_DEBUG&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// console_loglevel = 10&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;__init&lt;/span&gt; &lt;span class="nf"&gt;quiet_kernel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;console_loglevel&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CONSOLE_LOGLEVEL_QUIET&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// console_loglevel = 4&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;early_param&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;debug&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;debug_kernel&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;early_param&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;quiet&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;quiet_kernel&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在 4.1 的核心中，主要有兩種方式處理核心參數，其中一種較單純，使用 &lt;a class="reference external" href="http://lxr.free-electrons.com/source/include/linux/init.h?v=4.1#L243"&gt;struct obs_kernel_param&lt;/a&gt; 來記錄字串參數與處理函式的關聯，並透過 __setup_param()
macro 來設定。early_param() 屬於這種方式。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;obs_kernel_param&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;             &lt;span class="c1"&gt;// param&amp;#39;s name&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;setup_func&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="c1"&gt;// handler function&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;early&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                   &lt;span class="c1"&gt;// true if it&amp;#39;s a early_param&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt; * Only for really core code.  See moduleparam.h for the normal way.&lt;/span&gt;
&lt;span class="cm"&gt; *&lt;/span&gt;
&lt;span class="cm"&gt; * Force the alignment so the compiler doesn&amp;#39;t space elements of the&lt;/span&gt;
&lt;span class="cm"&gt; * obs_kernel_param &amp;quot;array&amp;quot; too far apart in .init.setup.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="cp"&gt;#define __setup_param(str, unique_id, fn, early)              \&lt;/span&gt;
&lt;span class="cp"&gt;    static const char __setup_str_##unique_id[] __initconst   \&lt;/span&gt;
&lt;span class="cp"&gt;        __aligned(1) = str;                                   \&lt;/span&gt;
&lt;span class="hll"&gt;&lt;span class="cp"&gt;    static struct obs_kernel_param __setup_##unique_id        \&lt;/span&gt;
&lt;/span&gt;&lt;span class="cp"&gt;        __used __section(.init.setup)                         \&lt;/span&gt;
&lt;span class="cp"&gt;        __attribute__((aligned((sizeof(long)))))              \&lt;/span&gt;
&lt;span class="cp"&gt;        = { __setup_str_##unique_id, fn, early }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="hll"&gt;&lt;span class="cp"&gt;#define __setup(str, fn)   \&lt;/span&gt;
&lt;/span&gt;&lt;span class="cp"&gt;    __setup_param(str, fn, fn, 0)&lt;/span&gt;

&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt; * NOTE: fn is as per module_param, not __setup!&lt;/span&gt;
&lt;span class="cm"&gt; * Emits warning if fn returns non-zero.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="hll"&gt;&lt;span class="cp"&gt;#define early_param(str, fn)   \&lt;/span&gt;
&lt;/span&gt;&lt;span class="cp"&gt;    __setup_param(str, fn, fn, 1)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;值得注意的是: __setup_param() 會對 &lt;a class="reference external" href="http://lxr.free-electrons.com/source/include/linux/init.h?v=4.1#L243"&gt;struct obs_kernel_param&lt;/a&gt;
附加 __section(.init.setup) 屬性，透過這個 macro 定義的資料會被放在
&lt;code&gt;.init.setup&lt;/code&gt; section 之中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="parse-early-param"&gt;
&lt;h2&gt;parse_early_param&lt;/h2&gt;
&lt;p&gt;parse_early_param() 如其名，是核心用來解析 early_param 的函式。&lt;/p&gt;
&lt;p&gt;init/main.c: &lt;a class="reference external" href="http://lxr.free-electrons.com/source/init/main.c?v=4.1#L436"&gt;parse_early_param()&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/* Arch code calls this early on, or if not, just before other parsing. */&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;__init&lt;/span&gt; &lt;span class="nf"&gt;parse_early_param&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;done&lt;/span&gt; &lt;span class="n"&gt;__initdata&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;tmp_cmdline&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;COMMAND_LINE_SIZE&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;__initdata&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;done&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* All fall through to do_early_param. */&lt;/span&gt;
    &lt;span class="n"&gt;strlcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tmp_cmdline&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;boot_command_line&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;COMMAND_LINE_SIZE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;parse_early_options&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tmp_cmdline&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;done&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;__init&lt;/span&gt; &lt;span class="nf"&gt;parse_early_options&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;cmdline&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;parse_args&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;early options&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cmdline&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="cm"&gt;/*kernel_param=*/&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;do_early_param&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;上面的 &lt;a class="reference external" href="http://lxr.free-electrons.com/source/kernel/params.c?v=4.1#L191"&gt;parse_args()&lt;/a&gt; 會將 cmdline 拆成一組一組的 param, value，傳入 do_early_param()&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/* Check for early params. */&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;__init&lt;/span&gt; &lt;span class="nf"&gt;do_early_param&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;unused&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;obs_kernel_param&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;__setup_start&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;__setup_end&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;early&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;parameq&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt;          &lt;span class="c1"&gt;// if p-&amp;gt;early is true&lt;/span&gt;
            &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;strcmp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;console&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;
             &lt;span class="n"&gt;strcmp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;earlycon&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="hll"&gt;            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;setup_func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                     &lt;span class="c1"&gt;// call param&amp;#39;s setup_func()&lt;/span&gt;
&lt;/span&gt;                &lt;span class="n"&gt;pr_warn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Malformed early option &amp;#39;%s&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="cm"&gt;/* We accept everything at this stage. */&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;還記得上面提到 __setup_param() 會附加 __section(.init.setup) 屬性到 &lt;a class="reference external" href="http://lxr.free-electrons.com/source/include/linux/init.h?v=4.1#L243"&gt;struct obs_kernel_param&lt;/a&gt;
的資料上嗎？核心在這邊使用了一個技巧，透過這個屬性，讓 linker 把 struct obs_kernel_param
的資料集中在一起，然後利用 __setup_start 和 __setup_end 將這個區域標示出來。&lt;/p&gt;
&lt;p&gt;__setup_start 和 __setup_end 實際上是被定義在 linker script
&lt;em&gt;include/asm-generic/vmlinux.lds.h&lt;/em&gt; 之中:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
#define INIT_SETUP(initsetup_align)         \
    . = ALIGN(initsetup_align);             \
    VMLINUX_SYMBOL(__setup_start) = .;      \
    *(.init.setup)                          \
    VMLINUX_SYMBOL(__setup_end) = .;
&lt;/pre&gt;
&lt;p&gt;觀察 System.map 可以了解實際的布局 (下面是 x86_64 的 System.map)&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
ffffffff81e7c9b0 T __setup_start
ffffffff81e7c9c8 t __setup_rdinit_setup
ffffffff81e7c9e0 t __setup_init_setup
ffffffff81e7c9f8 t __setup_loglevel
ffffffff81e7ca10 t __setup_quiet_kernel
ffffffff81e7ca28 t __setup_debug_kernel
...
ffffffff81e7e5b8 T __setup_end
&lt;/pre&gt;
&lt;p&gt;了解這個技巧，do_early_param() 的程式碼就很容易理解了，基本上就是逐個比較 &lt;a class="reference external" href="http://lxr.free-electrons.com/source/include/linux/init.h?v=4.1#L243"&gt;struct obs_kernel_param&lt;/a&gt;
是不是符合傳進來的 param name，若符合則將值傳入 setup_func() 中進行設定。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="module-param"&gt;
&lt;h2&gt;Module param&lt;/h2&gt;
&lt;p&gt;上面討論的 obs_kernel_param 的 obs 是 obsolete 的意思，看起來是打算讓它功成身退，但是一直沒動作，就這樣一直放著...。 而用來取代舊的參數處理結構的是升級後的 &lt;a class="reference external" href="http://lxr.free-electrons.com/source/include/linux/moduleparam.h?v=4.1#L68"&gt;struct kernel_param&lt;/a&gt;。從它被放在 include/linux/moduleparam.h 大概可以猜測新的結構主要是以支援模組參數為主，擴增到一般性的核心參數。&lt;/p&gt;
&lt;blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;kernel_param&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;kernel_param_ops&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ops&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;u16&lt;/span&gt; &lt;span class="n"&gt;perm&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;s8&lt;/span&gt; &lt;span class="n"&gt;level&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;u8&lt;/span&gt; &lt;span class="n"&gt;flags&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;union&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;kparam_string&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;kparam_array&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;arr&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;新的 &lt;a class="reference external" href="http://lxr.free-electrons.com/source/include/linux/moduleparam.h?v=4.1#L68"&gt;struct kernel_param&lt;/a&gt; 更為一般化，物件化，kernel_param_ops 提供 set/get method，負責參數的設定與保存。除了在啟動時可以經由 bootloader 設定參數，開機之後，kernel_param
也會被掛載到 sysfs 上，可以透過
/sys/module/&lt;span class="blue"&gt;&amp;lt;module-name&amp;gt;&lt;/span&gt;/parameters/&lt;span class="blue"&gt;&amp;lt;param-name&amp;gt;&lt;/span&gt;
讀取或設定參數。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;kernel_param_ops&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* How the ops should behave */&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;flags&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="cm"&gt;/* Returns 0, or -errno.  arg is in kp-&amp;gt;arg. */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;set&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;kernel_param&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;kp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="cm"&gt;/* Returns length written or -errno.  Buffer is 4k (ie. be short!) */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;buffer&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;kernel_param&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;kp&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="cm"&gt;/* Optional function to free kp-&amp;gt;arg when module unloaded. */&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="cm"&gt;/* Special one for strings we want to copy into */&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;kparam_string&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;maxlen&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="cm"&gt;/* Special one for arrays */&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;kparam_array&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;elemsize&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;kernel_param_ops&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ops&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;elem&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/* This is the fundamental function for registering boot/module parameters. */&lt;/span&gt;
&lt;span class="cp"&gt;#define __module_param_call(prefix, name, ops, arg, perm, level, flags) \&lt;/span&gt;
&lt;span class="cp"&gt;    &lt;/span&gt;&lt;span class="cm"&gt;/* Default value instead of permissions? */&lt;/span&gt;&lt;span class="cp"&gt;                         \&lt;/span&gt;
&lt;span class="cp"&gt;    static const char __param_str_##name[] = prefix #name;              \&lt;/span&gt;
&lt;span class="hll"&gt;&lt;span class="cp"&gt;    static struct kernel_param __moduleparam_const __param_##name       \&lt;/span&gt;
&lt;/span&gt;&lt;span class="cp"&gt;    __used                                                              \&lt;/span&gt;
&lt;span class="cp"&gt;    __attribute__ ((unused,__section__ (&amp;quot;__param&amp;quot;),aligned(sizeof(void *)))) \&lt;/span&gt;
&lt;span class="cp"&gt;    = { __param_str_##name, ops, VERIFY_OCTAL_PERMISSIONS(perm), level, flags, { arg } }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a class="reference external" href="http://lxr.free-electrons.com/source/include/linux/moduleparam.h?v=4.1#L68"&gt;struct kernel_param&lt;/a&gt; 主要是透過 __module_param_call() 這個 macro 來設定，與
struct obs_kernel_param 類似，這個 macro 會將 __section__ (&amp;quot;__param&amp;quot;) 的屬性設給
struct kernel_param 的資料，讓 linker 將資料集中在一起。&lt;/p&gt;
&lt;p&gt;另外，在上面的 macro 中我們可以發現如下的參數名宣告:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
static const char __param_str_##name[] = prefix #name;
&lt;/pre&gt;
&lt;p&gt;這個字串會被指派給 struct kernel_param 的 name 欄位。新的 struct kernel_param 被引入的同時，參數的命名方式也做了調整，新的命名方式引入了
module name 當作前綴 (prefix)，這是一種命名空間 (namespace) 的概念，新的命名規則讓各個模組更容易擁有屬於自已的參數，而不必太過煩腦命名衝突的問題。&lt;/p&gt;
&lt;p&gt;模組參數通常以 module_param() 或是以 module_param_named() 來宣告。
以 &amp;quot;printk&amp;quot; 模組的 &amp;quot;time&amp;quot; 參數為例 (kernel/printk/printk.c: &lt;a class="reference external" href="http://lxr.free-electrons.com/source/kernel/printk/printk.c?v=4.1#L996"&gt;printk_time&lt;/a&gt;)，宣告如下:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
static bool printk_time = IS_ENABLED(CONFIG_PRINTK_TIME);
module_param_named(time, printk_time, bool, S_IRUGO | S_IWUSR);
&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;name: &lt;code&gt;&amp;quot;time&amp;quot;&lt;/code&gt; =&amp;gt; &lt;code&gt;&amp;quot;printk.time&amp;quot;&lt;/code&gt; with KBUILD_MODNAME &amp;quot;printk&amp;quot; and a &amp;quot;.&amp;quot; as prefix&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;value: &lt;code&gt;printk_time&lt;/code&gt; (the actual lvalue to alter)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;type: &lt;code&gt;bool&lt;/code&gt; =&amp;gt; &lt;code&gt;param_ops_bool&lt;/code&gt; (the set &amp;amp; get operations for this parameter)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;perm: &lt;code&gt;S_IRUGO | S_IWUSR&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;the parameter &lt;code&gt;&amp;quot;printk.time&amp;quot;&lt;/code&gt; can also be found at &lt;em&gt;/sys/module/printk/parameters/time&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;值的特別一提的是第三個參數 type：
新的 struct kernel_param 針對像 bool, int, byte ... 等基礎的通用型態提供共用的
struct kernel_param_ops 及其 set/get method，並以 &lt;code&gt;param_ops_##type&lt;/code&gt; 命名。在上面例子中，&amp;quot;printk.time&amp;quot; 是 bool 型態的參數，會透過 &lt;code&gt;param_ops_bool&lt;/code&gt; 存取設定。其他支援的型態請參照下面 module_param() 的註解說明。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * module_param - typesafe helper for a module/cmdline parameter&lt;/span&gt;
&lt;span class="cm"&gt; * @value: the variable to alter, and exposed parameter name.&lt;/span&gt;
&lt;span class="cm"&gt; * @type: the type of the parameter&lt;/span&gt;
&lt;span class="cm"&gt; * @perm: visibility in sysfs.&lt;/span&gt;
&lt;span class="cm"&gt; *&lt;/span&gt;
&lt;span class="cm"&gt; * @value becomes the module parameter, or (prefixed by KBUILD_MODNAME and a&lt;/span&gt;
&lt;span class="cm"&gt; * &amp;quot;.&amp;quot;) the kernel commandline parameter.  Note that - is changed to _, so&lt;/span&gt;
&lt;span class="cm"&gt; * the user can use &amp;quot;foo-bar=1&amp;quot; even for variable &amp;quot;foo_bar&amp;quot;.&lt;/span&gt;
&lt;span class="cm"&gt; *&lt;/span&gt;
&lt;span class="cm"&gt; * @perm is 0 if the the variable is not to appear in sysfs, or 0444&lt;/span&gt;
&lt;span class="cm"&gt; * for world-readable, 0644 for root-writable, etc.  Note that if it&lt;/span&gt;
&lt;span class="cm"&gt; * is writable, you may need to use kparam_block_sysfs_write() around&lt;/span&gt;
&lt;span class="cm"&gt; * accesses (esp. charp, which can be kfreed when it changes).&lt;/span&gt;
&lt;span class="cm"&gt; *&lt;/span&gt;
&lt;span class="cm"&gt; * The @type is simply pasted to refer to a param_ops_##type and a&lt;/span&gt;
&lt;span class="cm"&gt; * param_check_##type: for convenience many standard types are provided but&lt;/span&gt;
&lt;span class="cm"&gt; * you can create your own by defining those variables.&lt;/span&gt;
&lt;span class="cm"&gt; *&lt;/span&gt;
&lt;span class="cm"&gt; * Standard types are:&lt;/span&gt;
&lt;span class="cm"&gt; *  byte, short, ushort, int, uint, long, ulong&lt;/span&gt;
&lt;span class="cm"&gt; *  charp: a character pointer&lt;/span&gt;
&lt;span class="cm"&gt; *  bool: a bool, values 0/1, y/n, Y/N.&lt;/span&gt;
&lt;span class="cm"&gt; *  invbool: the above, only sense-reversed (N = true).&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="hll"&gt;&lt;span class="cp"&gt;#define module_param(name, type, perm)   \&lt;/span&gt;
&lt;/span&gt;&lt;span class="cp"&gt;    module_param_named(name, name, type, perm)&lt;/span&gt;


&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * module_param_named - typesafe helper for a renamed module/cmdline parameter&lt;/span&gt;
&lt;span class="cm"&gt; * @name: a valid C identifier which is the parameter name.&lt;/span&gt;
&lt;span class="cm"&gt; * @value: the actual lvalue to alter.&lt;/span&gt;
&lt;span class="cm"&gt; * @type: the type of the parameter&lt;/span&gt;
&lt;span class="cm"&gt; * @perm: visibility in sysfs.&lt;/span&gt;
&lt;span class="cm"&gt; *&lt;/span&gt;
&lt;span class="cm"&gt; * Usually it&amp;#39;s a good idea to have variable names and user-exposed names the&lt;/span&gt;
&lt;span class="cm"&gt; * same, but that&amp;#39;s harder if the variable must be non-static or is inside a&lt;/span&gt;
&lt;span class="cm"&gt; * structure.  This allows exposure under a different name.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="hll"&gt;&lt;span class="cp"&gt;#define module_param_named(name, value, type, perm)            \&lt;/span&gt;
&lt;/span&gt;&lt;span class="cp"&gt;    param_check_##type(name, &amp;amp;(value));                        \&lt;/span&gt;
&lt;span class="cp"&gt;    module_param_cb(name, &amp;amp;param_ops_##type, &amp;amp;value, perm);    \&lt;/span&gt;
&lt;span class="cp"&gt;    __MODULE_PARM_TYPE(name, #type)&lt;/span&gt;


&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * module_param_cb - general callback for a module/cmdline parameter&lt;/span&gt;
&lt;span class="cm"&gt; * @name: a valid C identifier which is the parameter name.&lt;/span&gt;
&lt;span class="cm"&gt; * @ops: the set &amp;amp; get operations for this parameter.&lt;/span&gt;
&lt;span class="cm"&gt; * @perm: visibility in sysfs.&lt;/span&gt;
&lt;span class="cm"&gt; *&lt;/span&gt;
&lt;span class="cm"&gt; * The ops can have NULL set or get functions.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="hll"&gt;&lt;span class="cp"&gt;#define module_param_cb(name, ops, arg, perm)  \&lt;/span&gt;
&lt;/span&gt;&lt;span class="cp"&gt;    __module_param_call(MODULE_PARAM_PREFIX, name, ops, arg, perm, -1, 0)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了 module 外，struct kernel_param 也可用在一般核心的參數設定上，使用 core_param() macro 來宣告，因為不是給特定模組的參數，所以前綴 (prefix) 為空。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * core_param - define a historical core kernel parameter.&lt;/span&gt;
&lt;span class="cm"&gt; * @name: the name of the cmdline and sysfs parameter (often the same as var)&lt;/span&gt;
&lt;span class="cm"&gt; * @var: the variable&lt;/span&gt;
&lt;span class="cm"&gt; * @type: the type of the parameter&lt;/span&gt;
&lt;span class="cm"&gt; * @perm: visibility in sysfs&lt;/span&gt;
&lt;span class="cm"&gt; *&lt;/span&gt;
&lt;span class="cm"&gt; * core_param is just like module_param(), but cannot be modular and&lt;/span&gt;
&lt;span class="cm"&gt; * doesn&amp;#39;t add a prefix (such as &amp;quot;printk.&amp;quot;).  This is for compatibility&lt;/span&gt;
&lt;span class="cm"&gt; * with __setup(), and it makes sense as truly core parameters aren&amp;#39;t&lt;/span&gt;
&lt;span class="cm"&gt; * tied to the particular file they&amp;#39;re in.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="hll"&gt;&lt;span class="cp"&gt;#define core_param(name, var, type, perm)    \&lt;/span&gt;
&lt;/span&gt;&lt;span class="cp"&gt;    param_check_##type(name, &amp;amp;(var));        \&lt;/span&gt;
&lt;span class="cp"&gt;    __module_param_call(&amp;quot;&amp;quot;, name, &amp;amp;param_ops_##type, &amp;amp;var, perm, -1, 0)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="parse-args"&gt;
&lt;h2&gt;parse_args&lt;/h2&gt;
&lt;p&gt;&lt;a class="reference external" href="http://lxr.free-electrons.com/source/kernel/params.c?v=4.1#L191"&gt;parse_args()&lt;/a&gt; 負責解析字串參數，處理屬於 struct kernel_param 的參數設定，在核心啟動時由
start_kernel() 處進入。&lt;/p&gt;
&lt;blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;asmlinkage&lt;/span&gt; &lt;span class="n"&gt;__visible&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;__init&lt;/span&gt; &lt;span class="nf"&gt;start_kernel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;command_line&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// a pointer to the kernel command line&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;after_dashes&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;omitted&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;

    &lt;span class="n"&gt;pr_notice&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Kernel command line: %s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;boot_command_line&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;parse_early_param&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;              &lt;span class="c1"&gt;// parse options for early_param()&lt;/span&gt;
&lt;span class="hll"&gt;    &lt;span class="n"&gt;after_dashes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parse_args&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Booting kernel&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;static_command_line&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  &lt;span class="c1"&gt;// parse options for module_param(), module_param_named(), core_param()&lt;/span&gt;
&lt;/span&gt;                  &lt;span class="n"&gt;__start___param&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;                   &lt;span class="c1"&gt;// array of struct kernel_param&lt;/span&gt;
                  &lt;span class="n"&gt;__stop___param&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;__start___param&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  &lt;span class="c1"&gt;// number of params&lt;/span&gt;
                  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;unknown_bootoption&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;      &lt;span class="c1"&gt;// parse options for __setup()&lt;/span&gt;

    &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;omitted&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;a class="reference external" href="http://lxr.free-electrons.com/source/kernel/params.c?v=4.1#L191"&gt;parse_args()&lt;/a&gt; 要求提供 kernel_param 的處理陣列。
這邊和上面提到的 do_early_param() 使用一樣的技巧，
__start___param 和 __stop___param 被定義在 linker script
&lt;em&gt;include/asm-generic/vmlinux.lds.h&lt;/em&gt; 裡，中間是 __param section，
由 module_param(), module_param_named(), core_param() 等 macro 宣告的
struct kernel_param 參數處理結構。&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
/* Built-in module parameters. */             \
__param : AT(ADDR(__param) - LOAD_OFFSET) {   \
    VMLINUX_SYMBOL(__start___param) = .;      \
    *(__param)                                \
    VMLINUX_SYMBOL(__stop___param) = .;       \
}
&lt;/pre&gt;
&lt;p&gt;來看一下 System.map (x86_64)，觀察一下實際的布局情形:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
ffffffff81ba3768 R __start___param
ffffffff81ba3788 r __param_dis_ucode_ldr
ffffffff81ba37a8 r __param_trace_pc
ffffffff81ba37c8 r __param_nommiotrace
ffffffff81ba37e8 r __param_filter_offset
ffffffff81ba3808 r __param_panic_on_warn
ffffffff81ba3828 r __param_pause_on_oops
ffffffff81ba3848 r __param_panic
...
ffffffff81ba55e8 R __stop___param
&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a class="reference external" href="http://lxr.free-electrons.com/source/kernel/params.c?v=4.1#L191"&gt;parse_args()&lt;/a&gt; 的實作:&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;由 next_arg() 解析出下一對的 param, value 組合&lt;/li&gt;
&lt;li&gt;由 parse_one() 對應到符合的 struct kernel_param 資料&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/* Args looks like &amp;quot;foo=bar,bar2 baz=fuz wiz&amp;quot;. */&lt;/span&gt;
&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;parse_args&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;doing&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  &lt;span class="c1"&gt;// doing message. e.g. &amp;quot;early options&amp;quot;, &amp;quot;Booting kernel&amp;quot;, &amp;quot;Setting init args&amp;quot;&lt;/span&gt;
         &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;                 &lt;span class="c1"&gt;// command line string&lt;/span&gt;
         &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;kernel_param&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  &lt;span class="c1"&gt;// array of struct kernel_param&lt;/span&gt;
         &lt;span class="n"&gt;s16&lt;/span&gt; &lt;span class="n"&gt;min_level&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s16&lt;/span&gt; &lt;span class="n"&gt;max_level&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
         &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;unknown&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;doing&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* Chew leading spaces */&lt;/span&gt;
    &lt;span class="n"&gt;args&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;skip_spaces&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;pr_debug&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;doing %s, parsing ARGS: &amp;#39;%s&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;doing&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ret&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;irq_was_disabled&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="hll"&gt;        &lt;span class="n"&gt;args&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;next_arg&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;// get the next [param, val] pair&lt;/span&gt;
&lt;/span&gt;        &lt;span class="cm"&gt;/* Stop at -- */&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;strcmp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;--&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;irq_was_disabled&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;irqs_disabled&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="hll"&gt;        &lt;span class="n"&gt;ret&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parse_one&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;doing&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;num&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
&lt;/span&gt;                &lt;span class="n"&gt;min_level&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;max_level&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;unknown&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;irq_was_disabled&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;irqs_disabled&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
            &lt;span class="n"&gt;pr_warn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%s: option &amp;#39;%s&amp;#39; enabled irq&amp;#39;s!&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;doing&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;omitted&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="cm"&gt;/* All parsed OK. */&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;parse_one() 以線性搜尋的方式，比對出符合的 struct kernel_param。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;parse_one&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  &lt;span class="c1"&gt;// the [param, val] pair&lt;/span&gt;
             &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;doing&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
             &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;kernel_param&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="n"&gt;num_params&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
             &lt;span class="n"&gt;s16&lt;/span&gt; &lt;span class="n"&gt;min_level&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;s16&lt;/span&gt; &lt;span class="n"&gt;max_level&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
             &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;handle_unknown&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;doing&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;err&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* Find parameter */&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_params&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="hll"&gt;        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;parameq&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;     &lt;span class="c1"&gt;// match param&amp;#39;s name with kernel_param&lt;/span&gt;
&lt;/span&gt;            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;level&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;min_level&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;level&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;max_level&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="cm"&gt;/* No one handled NULL, so do it here. */&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;ops&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;flags&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;KERNEL_PARAM_OPS_FL_NOARG&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;EINVAL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;pr_debug&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;handling %s with %p&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;ops&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;set&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;mutex_lock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;param_lock&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;param_check_unsafe&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
&lt;span class="hll"&gt;            &lt;span class="n"&gt;err&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;ops&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;params&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;   &lt;span class="c1"&gt;// call kernel_param_ops-&amp;gt;set()&lt;/span&gt;
&lt;/span&gt;            &lt;span class="n"&gt;mutex_unlock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;param_lock&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;err&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;handle_unknown&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;   &lt;span class="c1"&gt;// handle_unknown = do_early_param(), or unknown_bootoption(), ...&lt;/span&gt;
        &lt;span class="n"&gt;pr_debug&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;doing %s: %s=&amp;#39;%s&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;doing&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;handle_unknown&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;val&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;doing&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;pr_debug&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Unknown argument &amp;#39;%s&amp;#39;&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;param&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;ENOENT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="reference"&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;bootparam(7): &lt;a class="reference external" href="http://man7.org/linux/man-pages/man7/bootparam.7.html"&gt;http://man7.org/linux/man-pages/man7/bootparam.7.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Kernel Parameters: &lt;a class="reference external" href="https://www.kernel.org/doc/Documentation/kernel-parameters.txt"&gt;https://www.kernel.org/doc/Documentation/kernel-parameters.txt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;The Linux/x86 Boot Protocol: &lt;a class="reference external" href="https://www.kernel.org/doc/Documentation/x86/boot.txt"&gt;https://www.kernel.org/doc/Documentation/x86/boot.txt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Booting ARM Linux: &lt;a class="reference external" href="https://www.kernel.org/doc/Documentation/arm/Booting"&gt;https://www.kernel.org/doc/Documentation/arm/Booting&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Daniel Lin</dc:creator><pubDate>Sat, 13 Aug 2016 00:00:00 +0800</pubDate><guid>tag:danielmaker.github.io,2016-08-13:blog/linux/kernel_parameter_parsing.html</guid><category>Linux kernel</category></item><item><title>深入淺出 start_kernel()</title><link>https://danielmaker.github.io/blog/linux/inside_start_kernel.html</link><description>&lt;p&gt;當 bootloader 載入核心映像檔(zImage, or bzImage) 之後，在核心映像檔最開頭的 bootstrap code 會負責關閉中斷，初始化記憶體設定等硬體初始化工作，最後解壓縮內核。
不同的硬體架構會有不同的設定方式，大致的流程如下圖所示：&lt;/p&gt;
&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;
&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN"
 "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"&gt;
&lt;!-- Generated by graphviz version 2.38.0 (20140413.2041)
 --&gt;
&lt;!-- Title: start_kernel Pages: 1 --&gt;
&lt;svg width="366pt" height="286pt"
 viewBox="0.00 0.00 366.19 286.00" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"&gt;
&lt;g id="graph0" class="graph" transform="scale(1 1) rotate(0) translate(4 282)"&gt;
&lt;title&gt;start_kernel&lt;/title&gt;
&lt;!-- booting --&gt;
&lt;g id="node1" class="node"&gt;&lt;title&gt;booting&lt;/title&gt;
&lt;polygon fill="lightgrey" stroke="black" points="223.382,-278 80.1821,-278 80.1821,-242 223.382,-242 223.382,-278"/&gt;
&lt;text text-anchor="middle" x="151.782" y="-255.8" font-family="monospace" font-size="14.00"&gt;arch/*/boot/&lt;/text&gt;
&lt;/g&gt;
&lt;!-- low_level_init --&gt;
&lt;g id="node2" class="node"&gt;&lt;title&gt;low_level_init&lt;/title&gt;
&lt;polygon fill="lightgrey" stroke="black" points="303.347,-136 0.217461,-136 0.217461,-100 303.347,-100 303.347,-136"/&gt;
&lt;text text-anchor="middle" x="151.782" y="-113.8" font-family="monospace" font-size="14.00"&gt;arch/*/kernel/head*.S, head*.c&lt;/text&gt;
&lt;/g&gt;
&lt;!-- booting&amp;#45;&amp;gt;low_level_init --&gt;
&lt;g id="edge1" class="edge"&gt;&lt;title&gt;booting&amp;#45;&amp;gt;low_level_init&lt;/title&gt;
&lt;path fill="none" stroke="black" d="M151.782,-241.833C151.782,-218.007 151.782,-174.658 151.782,-146.349"/&gt;
&lt;polygon fill="black" stroke="black" points="155.282,-146.307 151.782,-136.307 148.282,-146.307 155.282,-146.307"/&gt;
&lt;text text-anchor="start" x="151.782" y="-212.8" font-family="Times,serif" font-size="14.00"&gt; &amp;#160;&amp;#160;Booting &lt;/text&gt;
&lt;text text-anchor="start" x="151.782" y="-198.8" font-family="Times,serif" font-size="14.00"&gt; &amp;#160;&amp;#160;&amp;#45; disable interrupt &lt;/text&gt;
&lt;text text-anchor="start" x="151.782" y="-184.8" font-family="Times,serif" font-size="14.00"&gt; &amp;#160;&amp;#160;&amp;#45; prepare memory &lt;/text&gt;
&lt;text text-anchor="start" x="151.782" y="-170.8" font-family="Times,serif" font-size="14.00"&gt; &amp;#160;&amp;#160;&amp;#45; clean bss section &lt;/text&gt;
&lt;text text-anchor="start" x="151.782" y="-156.8" font-family="Times,serif" font-size="14.00"&gt; &amp;#160;&amp;#160;&amp;#45; decompress zImage (or bzImag) &amp;#160;&lt;/text&gt;
&lt;/g&gt;
&lt;!-- start_kernel --&gt;
&lt;g id="node3" class="node"&gt;&lt;title&gt;start_kernel&lt;/title&gt;
&lt;polygon fill="#66ff99" stroke="black" points="286.551,-36 17.0135,-36 17.0135,-0 286.551,-0 286.551,-36"/&gt;
&lt;text text-anchor="middle" x="151.782" y="-13.8" font-family="monospace" font-size="14.00"&gt;init/main.c: start_kernel()&lt;/text&gt;
&lt;/g&gt;
&lt;!-- low_level_init&amp;#45;&amp;gt;start_kernel --&gt;
&lt;g id="edge2" class="edge"&gt;&lt;title&gt;low_level_init&amp;#45;&amp;gt;start_kernel&lt;/title&gt;
&lt;path fill="none" stroke="black" d="M151.782,-99.9297C151.782,-85.1248 151.782,-63.432 151.782,-46.2312"/&gt;
&lt;polygon fill="black" stroke="black" points="155.282,-46.2035 151.782,-36.2035 148.282,-46.2035 155.282,-46.2035"/&gt;
&lt;text text-anchor="start" x="151.782" y="-70.8" font-family="Times,serif" font-size="14.00"&gt; &amp;#160;&amp;#160;Low&amp;#45;level initialization &lt;/text&gt;
&lt;text text-anchor="start" x="151.782" y="-56.8" font-family="Times,serif" font-size="14.00"&gt; &amp;#160;&amp;#160;&amp;#45; switch to virtual memory &lt;/text&gt;
&lt;/g&gt;
&lt;/g&gt;
&lt;/svg&gt;
&lt;p&gt;在 start_kernel() 之前的 bootstrap code 最主要的任務就是將環境準備好，滿足 start_kernel()
的要求，然後就轉到 start_kernel() ， 由 start_kernel() 開始進行一般化 (generic and architecture independent)
的初始化流程。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://lxr.free-electrons.com/source/init/main.c?v=4.1#L492"&gt;start_kernel()&lt;/a&gt; 是核心的主要進入點，核心從這裡開始走訪各個子系統的初始化函式。
以下是 version 4.1.15 的 start_kernel() ，大約呼叫了一百個左右的函式。若每個函式都能理解的話，那麼我想對 Linux kernel 也就有相當的了解了。
下面將 start_kernel() 呼叫到的函式加上註解說明，方便大家理解各個函式的作用。&lt;/p&gt;
&lt;blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;asmlinkage&lt;/span&gt; &lt;span class="n"&gt;__visible&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;__init&lt;/span&gt; &lt;span class="nf"&gt;start_kernel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;command_line&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// a pointer to the kernel command line&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;after_dashes&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;// a pointer to the kernel command line after &amp;quot;--&amp;quot;, which will be passed to the init process&lt;/span&gt;

    &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;     * Need to run as early as possible, to initialize the&lt;/span&gt;
&lt;span class="cm"&gt;     * lockdep hash:&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="n"&gt;lockdep_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;             &lt;span class="c1"&gt;// lock dependency validator, https://www.kernel.org/doc/Documentation/locking/lockdep-design.txt&lt;/span&gt;
    &lt;span class="n"&gt;set_task_stack_end_magic&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;init_task&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;// setup magic number in the end of stack of init_task for overflow detection&lt;/span&gt;
    &lt;span class="n"&gt;smp_setup_processor_id&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;   &lt;span class="c1"&gt;// assign SMP CPU id. archs can override it.&lt;/span&gt;
    &lt;span class="n"&gt;debug_objects_early_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// infrastructure for lifetime debugging of objects, https://lwn.net/Articles/271614/&lt;/span&gt;

    &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;     * Set up the the initial canary ASAP:&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="n"&gt;boot_init_stack_canary&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;   &lt;span class="c1"&gt;// stack smashing protector, http://wiki.osdev.org/Stack_Smashing_Protector&lt;/span&gt;

    &lt;span class="n"&gt;cgroup_init_early&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;        &lt;span class="c1"&gt;// initialize cgroup subsystems, https://en.wikipedia.org/wiki/Cgroups&lt;/span&gt;

    &lt;span class="n"&gt;local_irq_disable&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;        &lt;span class="c1"&gt;// disable IRQ first because interrupt vector table has not been setup yet&lt;/span&gt;
    &lt;span class="n"&gt;early_boot_irqs_disabled&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt; * Interrupts are still disabled. Do necessary setups, then&lt;/span&gt;
&lt;span class="cm"&gt; * enable them&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
    &lt;span class="n"&gt;boot_cpu_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;                  &lt;span class="c1"&gt;// activate the first processor. mark the boot cpu &amp;quot;present&amp;quot;, &amp;quot;online&amp;quot; etc for SMP and UP case&lt;/span&gt;
    &lt;span class="n"&gt;page_address_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;              &lt;span class="c1"&gt;// initializes page_address_htable&lt;/span&gt;
    &lt;span class="n"&gt;pr_notice&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%s&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;linux_banner&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="hll"&gt;    &lt;span class="n"&gt;setup_arch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;command_line&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;        &lt;span class="c1"&gt;// architecture-specific setup&lt;/span&gt;
&lt;/span&gt;    &lt;span class="n"&gt;mm_init_cpumask&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;init_mm&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;        &lt;span class="c1"&gt;// =&amp;gt; cpumask_clear(mm-&amp;gt;cpu_vm_mask_var), for lazy TLB switches&lt;/span&gt;
    &lt;span class="n"&gt;setup_command_line&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;command_line&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// store the untouched command line&lt;/span&gt;
    &lt;span class="n"&gt;setup_nr_cpu_ids&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;               &lt;span class="c1"&gt;// set &amp;quot;nr_cpu_ids&amp;quot; according to the last bit in possible mask&lt;/span&gt;
    &lt;span class="n"&gt;setup_per_cpu_areas&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;            &lt;span class="c1"&gt;// per cpu memory allocator&lt;/span&gt;
    &lt;span class="n"&gt;smp_prepare_boot_cpu&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="cm"&gt;/* arch-specific boot-cpu hooks */&lt;/span&gt;

    &lt;span class="n"&gt;build_all_zonelists&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;// memory zones, https://www.kernel.org/doc/gorman/html/understand/understand005.html&lt;/span&gt;
    &lt;span class="n"&gt;page_alloc_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;                &lt;span class="c1"&gt;// add a handler for CPU hotplug&lt;/span&gt;

    &lt;span class="n"&gt;pr_notice&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Kernel command line: %s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;boot_command_line&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;parse_early_param&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;              &lt;span class="c1"&gt;// parse options for early_param()&lt;/span&gt;
    &lt;span class="n"&gt;after_dashes&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;parse_args&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Booting kernel&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                  &lt;span class="n"&gt;static_command_line&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;__start___param&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  &lt;span class="c1"&gt;// parse options for module_param(), module_param_named(), core_param()&lt;/span&gt;
                  &lt;span class="n"&gt;__stop___param&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;__start___param&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                  &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;unknown_bootoption&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;          &lt;span class="c1"&gt;// parse options for __setup()&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;IS_ERR_OR_NULL&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;after_dashes&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="n"&gt;parse_args&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Setting init args&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;after_dashes&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  &lt;span class="c1"&gt;// after_dashes will be passed to the init process as argv&lt;/span&gt;
               &lt;span class="n"&gt;set_init_arg&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;jump_label_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;         &lt;span class="c1"&gt;// Jump label: https://lwn.net/Articles/412072/&lt;/span&gt;

    &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;     * These use large bootmem allocations and must precede&lt;/span&gt;
&lt;span class="cm"&gt;     * kmem_cache_init()&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="n"&gt;setup_log_buf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;          &lt;span class="c1"&gt;// buf for printk&lt;/span&gt;
    &lt;span class="n"&gt;pidhash_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;            &lt;span class="c1"&gt;// pid hash table&lt;/span&gt;
    &lt;span class="n"&gt;vfs_caches_init_early&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;   &lt;span class="c1"&gt;// allocate and caches initialize for hash tables of dcache and inode&lt;/span&gt;
    &lt;span class="n"&gt;sort_main_extable&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;       &lt;span class="c1"&gt;// sort the kernel&amp;#39;s built-in exception table (for page faults)&lt;/span&gt;
    &lt;span class="n"&gt;trap_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;               &lt;span class="c1"&gt;// architecture-specific, interrupt vector table, handle hardware traps, exceptions and faults.&lt;/span&gt;
&lt;span class="hll"&gt;    &lt;span class="n"&gt;mm_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;                 &lt;span class="c1"&gt;// memory management&lt;/span&gt;
&lt;/span&gt;
    &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;     * Set up the scheduler prior starting any interrupts (such as the&lt;/span&gt;
&lt;span class="cm"&gt;     * timer interrupt). Full topology setup happens at smp_init()&lt;/span&gt;
&lt;span class="cm"&gt;     * time - but meanwhile we still have a functioning scheduler.&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
&lt;span class="hll"&gt;    &lt;span class="n"&gt;sched_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/span&gt;    &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;     * Disable preemption - early bootup scheduling is extremely&lt;/span&gt;
&lt;span class="cm"&gt;     * fragile until we cpu_idle() for the first time.&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="n"&gt;preempt_disable&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;WARN&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;irqs_disabled&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Interrupts were enabled *very* early, fixing it&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="n"&gt;local_irq_disable&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;idr_init_cache&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;          &lt;span class="c1"&gt;// idr: ID radix, sparse array indexed by the id to obtain the pointer&lt;/span&gt;
    &lt;span class="n"&gt;rcu_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;                &lt;span class="c1"&gt;// Read-Copy Update mechanism, https://www.kernel.org/doc/Documentation/RCU/&lt;/span&gt;

    &lt;span class="cm"&gt;/* trace_printk() and trace points may be used after this */&lt;/span&gt;
    &lt;span class="n"&gt;trace_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;              &lt;span class="c1"&gt;// https://www.kernel.org/doc/Documentation/trace/&lt;/span&gt;

    &lt;span class="n"&gt;context_tracking_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;   &lt;span class="c1"&gt;// prepare for using a static key in the context tracking subsystem&lt;/span&gt;
    &lt;span class="n"&gt;radix_tree_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;         &lt;span class="c1"&gt;// allocate a cache for radix_tree. [LWN] radix_tree: https://lwn.net/Articles/175432/&lt;/span&gt;
    &lt;span class="cm"&gt;/* init some links before init_ISA_irqs() */&lt;/span&gt;
    &lt;span class="n"&gt;early_irq_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;          &lt;span class="c1"&gt;// allocate caches for irq_desc, interrupt descriptor&lt;/span&gt;
    &lt;span class="n"&gt;init_IRQ&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;                &lt;span class="c1"&gt;// architecture-specific, initialize kernel&amp;#39;s interrupt subsystem and the interrupt controllers.&lt;/span&gt;
    &lt;span class="n"&gt;tick_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;               &lt;span class="c1"&gt;// initialize the tick control&lt;/span&gt;
    &lt;span class="n"&gt;rcu_init_nohz&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;init_timers&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;             &lt;span class="c1"&gt;// init timer stats, register cpu notifier, and open softirq for timer&lt;/span&gt;
    &lt;span class="n"&gt;hrtimers_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;           &lt;span class="c1"&gt;// high-resolution timer, https://www.kernel.org/doc/Documentation/timers/hrtimers.txt&lt;/span&gt;
    &lt;span class="n"&gt;softirq_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;            &lt;span class="c1"&gt;// initialize tasklet_vec and open softirq for tasklet&lt;/span&gt;
    &lt;span class="n"&gt;timekeeping_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;        &lt;span class="c1"&gt;// https://www.kernel.org/doc/Documentation/timers/timekeeping.txt&lt;/span&gt;
    &lt;span class="n"&gt;time_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;               &lt;span class="c1"&gt;// architecture-specific, timer initialization&lt;/span&gt;
    &lt;span class="n"&gt;sched_clock_postinit&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;    &lt;span class="c1"&gt;// start the high-resolution timer to keep sched_clock() properly updated and sets the initial epoch&lt;/span&gt;
    &lt;span class="n"&gt;perf_event_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;         &lt;span class="c1"&gt;// perf is a profiler tool for Linux, https://perf.wiki.kernel.org/index.php/Tutorial&lt;/span&gt;
    &lt;span class="n"&gt;profile_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;            &lt;span class="c1"&gt;// initializes basic kernel profiler&lt;/span&gt;
    &lt;span class="n"&gt;call_function_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;      &lt;span class="c1"&gt;// SMP initializes call_single_queue and register notifier&lt;/span&gt;
    &lt;span class="n"&gt;WARN&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;irqs_disabled&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Interrupts were enabled early&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;early_boot_irqs_disabled&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;local_irq_enable&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;        &lt;span class="c1"&gt;// after this point, interrupts are enabled&lt;/span&gt;

    &lt;span class="n"&gt;kmem_cache_init_late&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;    &lt;span class="c1"&gt;// post-initialization of cache (slab)&lt;/span&gt;

    &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;     * HACK ALERT! This is early. We&amp;#39;re enabling the console before&lt;/span&gt;
&lt;span class="cm"&gt;     * we&amp;#39;ve done PCI setups etc, and console_init() must be aware of&lt;/span&gt;
&lt;span class="cm"&gt;     * this. But we do want output early, in case something goes wrong.&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="n"&gt;console_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;            &lt;span class="c1"&gt;// call console initcalls to initialize the console device, usually it&amp;#39;s tty device.&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;panic_later&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;panic&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Too many boot %s vars at `%s&amp;#39;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;panic_later&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
              &lt;span class="n"&gt;panic_param&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;lockdep_info&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;            &lt;span class="c1"&gt;// print lockdep information&lt;/span&gt;

    &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;     * Need to run this when irqs are enabled, because it wants&lt;/span&gt;
&lt;span class="cm"&gt;     * to self-test [hard/soft]-irqs on/off lock inversion bugs&lt;/span&gt;
&lt;span class="cm"&gt;     * too:&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="n"&gt;locking_selftest&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;        &lt;span class="c1"&gt;// test various locking APIs: spinlocks, rwlocks, mutexes, and rwsemaphores&lt;/span&gt;

&lt;span class="cp"&gt;#ifdef CONFIG_BLK_DEV_INITRD&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;initrd_start&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;initrd_below_start_ok&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;
        &lt;span class="n"&gt;page_to_pfn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;virt_to_page&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;initrd_start&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;min_low_pfn&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;pr_crit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;initrd overwritten (0x%08lx &amp;lt; 0x%08lx) - disabling it.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
            &lt;span class="n"&gt;page_to_pfn&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;virt_to_page&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;initrd_start&lt;/span&gt;&lt;span class="p"&gt;)),&lt;/span&gt;
            &lt;span class="n"&gt;min_low_pfn&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;initrd_start&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;
    &lt;span class="n"&gt;page_ext_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;           &lt;span class="c1"&gt;// memory page extension, allocates memory for extended data per page&lt;/span&gt;
    &lt;span class="n"&gt;debug_objects_mem_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  &lt;span class="c1"&gt;// allocate a dedicated cache pool for debug objects&lt;/span&gt;
    &lt;span class="n"&gt;kmemleak_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;           &lt;span class="c1"&gt;// initialize kmemleak (memory leak check facility)&lt;/span&gt;
    &lt;span class="n"&gt;setup_per_cpu_pageset&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;   &lt;span class="c1"&gt;// allocate and initialize per cpu pagesets&lt;/span&gt;
    &lt;span class="n"&gt;numa_policy_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;        &lt;span class="c1"&gt;// allocate caches and do initialization for NUMA memory policy&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;late_time_init&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;        &lt;span class="c1"&gt;// default late_time_init is NULL. archs can override it&lt;/span&gt;
        &lt;span class="n"&gt;late_time_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;      &lt;span class="c1"&gt;// architecture-specific&lt;/span&gt;
    &lt;span class="n"&gt;sched_clock_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;        &lt;span class="c1"&gt;// set the time info for scheduler and make sched clock running&lt;/span&gt;
    &lt;span class="n"&gt;calibrate_delay&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;         &lt;span class="c1"&gt;// calibrate the delay loop&lt;/span&gt;
    &lt;span class="n"&gt;pidmap_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;             &lt;span class="c1"&gt;// initialize PID map for initial PID namespace&lt;/span&gt;
    &lt;span class="n"&gt;anon_vma_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;           &lt;span class="c1"&gt;// allocate a cache for &amp;quot;anon_vma&amp;quot; (anonymous memory), http://lwn.net/Kernel/Index/#anon_vma&lt;/span&gt;
    &lt;span class="n"&gt;acpi_early_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;         &lt;span class="c1"&gt;// initialize ACPI subsystem and populate the ACPI namespace&lt;/span&gt;
&lt;span class="cp"&gt;#ifdef CONFIG_X86&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;efi_enabled&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EFI_RUNTIME_SERVICES&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;  &lt;span class="c1"&gt;// Extensible Firmware Interface&lt;/span&gt;
        &lt;span class="n"&gt;efi_enter_virtual_mode&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;           &lt;span class="c1"&gt;// switch EFI to virtual mode, if possible&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;
&lt;span class="cp"&gt;#ifdef CONFIG_X86_ESPFIX64&lt;/span&gt;
    &lt;span class="cm"&gt;/* Should be run before the first non-init thread is created */&lt;/span&gt;
    &lt;span class="n"&gt;init_espfix_bsp&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;         &lt;span class="c1"&gt;// workaround to prevent leaking of 31:16 bits of the esp register, https://github.com/torvalds/linux/commit/3891a04aafd668686239349ea58f3314ea2af86b&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;
    &lt;span class="n"&gt;thread_info_cache_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  &lt;span class="c1"&gt;// allocate cache for thread_info if THREAD_SIZE &amp;lt; PAGE_SIZE&lt;/span&gt;
    &lt;span class="n"&gt;cred_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;               &lt;span class="c1"&gt;// credential&lt;/span&gt;
    &lt;span class="n"&gt;fork_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;               &lt;span class="c1"&gt;// allocate a cache for task_struct&lt;/span&gt;
    &lt;span class="n"&gt;proc_caches_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;        &lt;span class="c1"&gt;// allocate caches for sighand_struct, signal_struct, files_struct, fs_struct, mm_struct, and vm_area_struct&lt;/span&gt;
    &lt;span class="n"&gt;buffer_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;             &lt;span class="c1"&gt;// allocate a cache for buffer_head&lt;/span&gt;
    &lt;span class="n"&gt;key_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;                &lt;span class="c1"&gt;// initialize the authentication token and access key management&lt;/span&gt;
    &lt;span class="n"&gt;security_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;           &lt;span class="c1"&gt;// initialize the security framework, do_security_initcalls&lt;/span&gt;
    &lt;span class="n"&gt;dbg_late_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;           &lt;span class="c1"&gt;// late init for kgdb&lt;/span&gt;
&lt;span class="hll"&gt;    &lt;span class="n"&gt;vfs_caches_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;totalram_pages&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;// file system, including kernfs, sysfs, rootfs, mount tree&lt;/span&gt;
&lt;/span&gt;    &lt;span class="n"&gt;signals_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;            &lt;span class="c1"&gt;// allocate a cache for sigqueue&lt;/span&gt;
    &lt;span class="cm"&gt;/* rootfs populating might need page-writeback */&lt;/span&gt;
    &lt;span class="n"&gt;page_writeback_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;     &lt;span class="c1"&gt;// set the ratio limits for the dirty pages&lt;/span&gt;
    &lt;span class="n"&gt;proc_root_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;          &lt;span class="c1"&gt;// initializes /proc filesystem, and creates several standard entries like /proc/fs and /proc/driver&lt;/span&gt;
    &lt;span class="n"&gt;nsfs_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;               &lt;span class="c1"&gt;// mount pseudo-filesystem: nsfs&lt;/span&gt;
    &lt;span class="n"&gt;cpuset_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;             &lt;span class="c1"&gt;// initialize top_cpuset and the cpuset internal file system&lt;/span&gt;
    &lt;span class="n"&gt;cgroup_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;             &lt;span class="c1"&gt;// initialize the rest of cgroups&lt;/span&gt;
    &lt;span class="n"&gt;taskstats_init_early&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;    &lt;span class="c1"&gt;// allocate a cache and initialize per-task statistics&lt;/span&gt;
    &lt;span class="n"&gt;delayacct_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;          &lt;span class="c1"&gt;// per-task delay accounting&lt;/span&gt;

    &lt;span class="n"&gt;check_bugs&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;              &lt;span class="c1"&gt;// check for architecture-dependent bugs&lt;/span&gt;

    &lt;span class="n"&gt;acpi_subsystem_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;     &lt;span class="c1"&gt;// enable ACPI subsystem&lt;/span&gt;
    &lt;span class="n"&gt;sfi_init_late&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;           &lt;span class="c1"&gt;// SFI: Simple Firmware Interface. Map SFI tables again by using ioremap&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;efi_enabled&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EFI_RUNTIME_SERVICES&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  &lt;span class="c1"&gt;// Extensible Firmware Interface&lt;/span&gt;
        &lt;span class="n"&gt;efi_late_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;efi_free_boot_services&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;ftrace_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;             &lt;span class="c1"&gt;// function trace, https://www.kernel.org/doc/Documentation/trace/ftrace.txt&lt;/span&gt;

    &lt;span class="cm"&gt;/* Do the rest non-__init&amp;#39;ed, we&amp;#39;re now alive */&lt;/span&gt;
    &lt;span class="n"&gt;rest_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;關於 start_kernel() 的說明&lt;/h2&gt;
&lt;p&gt;以下將對 start_kernel() 所牽涉到的內核功能及特色 (feature) 做簡單說明及介紹。
由於我只是一個對 Linux 核心有興趣的業餘愛好者，並沒有實際從事跟核心相關的開發工作，對核心許多相關的主題只有粗淺的認識，缺乏更深入的了解，以下的說明將以觀念介紹為主，不對細節做太深入的探討。&lt;/p&gt;
&lt;p&gt;在 start_kernel() 的一開始，核心先對除錯機制進行初始化，除了 smp_setup_processor_id() 之外，其它四個函式呼叫都是核心用來除錯的機制。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre class="code literal-block"&gt;
lockdep_init();
set_task_stack_end_magic(&amp;amp;init_task);
smp_setup_processor_id();
debug_objects_early_init();
boot_init_stack_canary();
&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;div class="section" id="lockdep"&gt;
&lt;h3&gt;lockdep&lt;/h3&gt;
&lt;p&gt;lockdep 是核心用來檢查死鎖的機制，它會檢查一些會造成死鎖的上鎖方式，如重複上鎖 (AA)，不一致的上鎖順序 (AB-BA) 等問題。當它偵測到問題時會發出如下的警告:&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre class="code literal-block"&gt;
modprobe/2287 is trying to acquire lock:
 (&amp;amp;sio_locks[i].lock){-.-...}, at: [&amp;lt;c02867fd&amp;gt;] mutex_lock+0x21/0x24

but task is already holding lock:
 (&amp;amp;sio_locks[i].lock){-.-...}, at: [&amp;lt;c02867fd&amp;gt;] mutex_lock+0x21/0x24
&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;通常死鎖的問題很難重現，這增加了除錯的困難。
lockdep 的強大之處在於它不需要等到真正發生死鎖之後才回報問題，它被設計成只要發現只要發現有造成死鎖疑慮的上鎖步驟就會發出警告。&lt;/p&gt;
&lt;p&gt;不過由於內核非常頻繁地在上鎖解鎖，lockdep 的檢查無可避免地會拖慢系統的速度，在正式上線的內核不會將這個檢查打開，通常是在內部測試時會設定 CONFIG_LOCKDEP 啟動 lockdep 的檢查。&lt;/p&gt;
&lt;p&gt;由於 lockdep 實在太有用了，這個功能後來也變成一個獨立的工具，放在 tools/lib/lockdep/ 之下，讓 user space 的應用程式也能利用 lockdep 檢查死鎖。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.kernel.org/doc/Documentation/locking/lockdep-design.txt"&gt;https://www.kernel.org/doc/Documentation/locking/lockdep-design.txt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://lwn.net/Articles/185666/"&gt;LWN: The kernel lock validator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://lwn.net/Articles/536363/"&gt;LWN: User-space lockdep&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="set-task-stack-end-magic"&gt;
&lt;h3&gt;set_task_stack_end_magic()&lt;/h3&gt;
&lt;p&gt;set_task_stack_end_magic() 這個函式呼叫會在 task 的 stack 後面放一個檢查碼，
如果這個檢查碼的值被改變了，表示有人寫到 stack 以外的區域，也就是發生了 stack overflow。&lt;/p&gt;
&lt;blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#define STACK_END_MAGIC         0x57AC6E9D&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;set_task_stack_end_magic&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;task_struct&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;tsk&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;stackend&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;stackend&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;end_of_stack&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tsk&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;stackend&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;STACK_END_MAGIC&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="cm"&gt;/* for overflow detection */&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="debug-objects"&gt;
&lt;h3&gt;debug objects&lt;/h3&gt;
&lt;p&gt;debug objects 是針對核心內部物件的生命週期管理除錯的設施。根據原作者 Thomas Gleixner 的說明，
在核心開發常常會遇到物件的生命週期管理相關的錯誤，如:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;使用已經被釋放的物件&lt;/li&gt;
&lt;li&gt;重新初始化已經在作用的物件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;像這樣的問題很難被除錯，因為發生問題的點常不是問題的源頭 (root cause)。
以「使用已經被釋放的物件」這類型的錯誤來說，真正的問題可能是物件釋放的時間點不對。&lt;/p&gt;
&lt;p&gt;debug objects 就是設計來追蹤這一類關於物件生命週期管理相關的問題，子系統只需在相對應的函式加入
debug objects 的函式就可以利用它來幫忙追蹤物件的生命週期。
debug objects 原先是設計來追蹤 timer 的生命週期管理，除了 timer 以外，目前 worker queue 也有使用。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://lwn.net/Articles/271582/"&gt;LWN: object debugging infrastructure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://lwn.net/Articles/271614/"&gt;LWN: An object debugging infrastructure&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="boot-init-stack-canary"&gt;
&lt;h3&gt;boot_init_stack_canary()&lt;/h3&gt;
&lt;p&gt;這邊的 stack canary (金絲雀) 和上面 stack end magic 是同樣作用，都是放在 stack 後面用來檢查是否發生
stack overflow。 內核這邊的 boot_init_stack_canary() 函式的功用是設定一個不固定的 stack canary 值，用以防止 stack overflow 的攻擊，不過內核這邊也僅僅是設定一個不固定的 canary 值，真正的檢查
stack overflow 的機制是由 gcc 實現。 gcc 提供 -fstack-protector 編譯選項，它會參考這個 canary 值，
加入用來檢查的程式碼，在函式返回前檢查這個值是否被覆寫。 詳細的設明，推薦閱讀:
&lt;a class="reference external" href="https://www.ibm.com/developerworks/cn/linux/l-cn-gccstack/"&gt;IBM developerWorks: GCC 中的编译器堆栈保护技术&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;到目前為此，核心都只是在初始化一些除錯相關的功能。
在 boot_init_stack_canary() 之後有一個比較奇怪的傢伙 cgroup_init_early()，這是我們比較不熟悉的。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="cgroup-control-group"&gt;
&lt;h3&gt;cgroup (control group)&lt;/h3&gt;
&lt;p&gt;cgroup 是 control group 的簡稱，中文翻譯為控制群組。
cgroup 主要的功用是用來限制行程 (process) 對系統資源的使用，舉例來說，限制某個行程只能使用 20% 的 CPU，或是只使用 256MB 的 RAM。&lt;/p&gt;
&lt;p&gt;整個 cgroup 子系統主要是由 cgroup core 及子系統控制器 (controller) 所組成，常見的 cgroup 控制器有:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;cpu: 限制控制群組中的任務 CPU 的使用量。&lt;/li&gt;
&lt;li&gt;cpuset: 指派控制群組所使用的 CPU 與記憶體節點。&lt;/li&gt;
&lt;li&gt;cpuacct: CPU accounting controller, 產生關於控制群組中的任務，CPU 資源使用的報告。&lt;/li&gt;
&lt;li&gt;memmory: 限制控制群組中的任務所能使用的記憶體資源，並產生記憶體使用報告。&lt;/li&gt;
&lt;li&gt;devices: 允許或拒絕控制群組中的任務存取特定裝置。&lt;/li&gt;
&lt;li&gt;freezer: 中止或復原控制群組中的工作。&lt;/li&gt;
&lt;li&gt;blkio: 設置對區塊設備的輸入輸出限制，限制存取功能或頻寬。&lt;/li&gt;
&lt;li&gt;net_cls: Net class controller, 對網路封包標記 classid，讓流量控制器（tc）能夠辨識源自於特定控制群組的封包。&lt;/li&gt;
&lt;li&gt;ns: Namespace, 以命名空間將控制群組中的任務隔離。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;cgroup 是以階層（hierarchy）的形式被組織在一起，下層可使用的資源由上層繼承而來，
也就是說上層會限制下層能使用的資源。
以下圖來說， top_cgroup (root) 擁有 100% 的系統資源，假設 group A 被限制只能使用 50% 的 CPU，那麼 group B 和 group C 就不能使用超過 50% 的 CPU。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre class="code literal-block"&gt;
            top_cgroup (root)
               /      \
        group A        group D
       /       \
group B         group C
&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;cgroup 最初是在 2008 年時進到核心版本 2.6.24 之中，但是初版 cgroup 的設計太過複雜為許多人所詬病，
因此 Tejun Heo 在 2012 年發起討論，提議重新設計 cgroup，
在 2013 年時，由他所主導的 cgroup v2 被整合到核心版本 3.15 和 3.16 之中。&lt;/p&gt;
&lt;p&gt;新版的 cgroup 被稱為 cgroup v2，相較於舊版的 cgroup v1，它只允許一個唯一的階層（hierarchy）架構存在，這簡化了 cgroup 的設計。&lt;/p&gt;
&lt;p&gt;在 start_kernel() 中， cgroup 的初始化分為兩個步驟: cgroup_init_early() 及 cgroup_init()。
cgroup_init_early() 會先對需要先初始化的子系統進行初始化，主要是 root cgroup 的子系統，接下來的 cgroup_init() 會完成後續整個 cgroup 子系統的初始化。&lt;/p&gt;
&lt;blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * cgroup_init_early - cgroup initialization at system boot&lt;/span&gt;
&lt;span class="cm"&gt; *&lt;/span&gt;
&lt;span class="cm"&gt; * Initialize cgroups at system boot, and initialize any&lt;/span&gt;
&lt;span class="cm"&gt; * subsystems that request early init.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;__init&lt;/span&gt; &lt;span class="nf"&gt;cgroup_init_early&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;cgroup_sb_opts&lt;/span&gt; &lt;span class="n"&gt;__initdata&lt;/span&gt; &lt;span class="n"&gt;opts&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;cgroup_subsys&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;init_cgroup_root&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;cgrp_dfl_root&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;opts&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;cgrp_dfl_root&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cgrp&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flags&lt;/span&gt; &lt;span class="o"&gt;|=&lt;/span&gt; &lt;span class="n"&gt;CSS_NO_REF&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;RCU_INIT_POINTER&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;init_task&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cgroups&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;init_css_set&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;for_each_subsys&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

        &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;omitted&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;

        &lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cgroup_subsys_name&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;early_init&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="hll"&gt;            &lt;span class="n"&gt;cgroup_init_subsys&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ss&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="cm"&gt;/* early= */&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://access.redhat.com/documentation/zh-TW/Red_Hat_Enterprise_Linux/6/html/Resource_Management_Guide/ch01.html"&gt;Redhat: 控制群組（cgroup）簡介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.kernel.org/doc/Documentation/cgroup-v2.txt"&gt;https://www.kernel.org/doc/Documentation/cgroup-v2.txt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.kernel.org/doc/Documentation/cgroup-v1/"&gt;https://www.kernel.org/doc/Documentation/cgroup-v1/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Cgroups"&gt;https://en.wikipedia.org/wiki/Cgroups&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="cpu-mask"&gt;
&lt;h3&gt;CPU mask&lt;/h3&gt;
&lt;blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;__init&lt;/span&gt; &lt;span class="nf"&gt;boot_cpu_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cpu&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;smp_processor_id&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="cm"&gt;/* Mark the boot cpu &amp;quot;present&amp;quot;, &amp;quot;online&amp;quot; etc for SMP and UP case */&lt;/span&gt;
    &lt;span class="n"&gt;set_cpu_online&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cpu&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="c1"&gt;// set this CPU are available for scheduling&lt;/span&gt;
    &lt;span class="n"&gt;set_cpu_active&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cpu&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="c1"&gt;// set this CPU are available to migration (for load balance)&lt;/span&gt;
    &lt;span class="n"&gt;set_cpu_present&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cpu&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;// set this CPU are currently plugged in&lt;/span&gt;
    &lt;span class="n"&gt;set_cpu_possible&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cpu&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// set this CPU can be plugged in&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 Linux 內核中主要有 4 個 cpu mask array 記錄 CPU 的使用情形&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;cpu_possible_mask: 硬體上實際可用的 CPU， boot time 時決定&lt;/li&gt;
&lt;li&gt;cpu_present_mask: 目前指派使用的 CPU&lt;/li&gt;
&lt;li&gt;cpu_online_mask: 可以被排程的 CPU (boot CPU 以外的 CPU 由 smp_init() 完成 CPU 初始化後設定為 online)&lt;/li&gt;
&lt;li&gt;cpu_active_mask: 可以依據 domain/group 進行排程的 CPU (負載平衡)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果 CONFIG_HOTPLUG_CPU 有設定的話，Linux 內核啟動支援 CPU hotplug 的機制。
這邊的 hotplug 不是指硬體上的熱插拔，而是指系統可以動態決定
CPU 的使用，系統可以經由設定 cpu_present_mask 決定要使用的 CPU，舉例來說，系統可以在低負載時將一些 CPU 關掉，節省電源的消秏。
除了 cpu_present_mask 可以由外部設定，其它的 3個 mask 都是唯讀，由核心維護。&lt;/p&gt;
&lt;p&gt;關於 CPU mask 可以參考:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://lxr.free-electrons.com/source/include/linux/cpumask.h?v=4.1"&gt;include/linux/cpumask.h&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.kernel.org/doc/Documentation/cpu-hotplug.txt"&gt;https://www.kernel.org/doc/Documentation/cpu-hotplug.txt&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="memory-zones"&gt;
&lt;h3&gt;Memory zones&lt;/h3&gt;
&lt;p&gt;一個 32位元的處理器最多只能定址 4GB 的記憶體，在一般 Linux 核心的設定中，這 4GB 會被切分為
user space 3GB 和 kernel space 1GB。 如果某個裝置配備超過 4GB 的記憶體，Linux 要怎麼利用4GB 以上的記憶體呢？&lt;/p&gt;
&lt;p&gt;為了解決這個問題，Linux 引進了 high memory 機制，採用動態映射的方式將大於 4GB
的記憶體映射到 32位元的定址空間中。Linux 將實體記憶體 (Physical Address, PA)
區分為以下的區域 (zones):&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;ZONE_DMA (0-16 MB): 保留給 x86 ISA/PCI DMA 的實體記憶體區域。某些古老的 x86 ISA DMA
只能定址 0-16MB 的記憶體位址。&lt;/li&gt;
&lt;li&gt;ZONE_NORMAL (16-896 MB): 正常核心程式碼所能存取的區域。&lt;/li&gt;
&lt;li&gt;ZONE_HIGHMEM (896 MB 以上): 動態映射的記憶體區域。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外有2個新的 zone type 被加入到核心中:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;ZONE_DMA32 (16MB-4G) : 在 64 位元系統 (e.g. x86_64) 新增的 zone，延伸 ZONE_DMA 到 4G 的定址空間。&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://lwn.net/Articles/152337/"&gt;LWN: Add 4GB DMA32 zone&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ZONE_MOVABLE: 這是一個 pseudo zone，經由搬移被標記 ZONE_MOVABLE 的 page 來避免記憶體的碎片化。&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="https://lwn.net/Articles/219589/"&gt;LWN: Create ZONE_MOVABLE to partition memory between movable and non-movable pages&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;這邊要注意的是，上面所說的記憶體區域都是指實體記憶體空間，另外，核心在實體記憶體上是被放在低位址，在記憶體映射 (Memory Mapping) 建立之後，才會被映射到虛擬記憶體 (Virtual Address, VA) 的高位址上。&lt;/p&gt;
&lt;blockquote&gt;
&lt;object data="images/memory_zones.svg" style="width: 75%;" type="image/svg+xml"&gt;
&lt;/object&gt;
&lt;/blockquote&gt;
&lt;p&gt;在核心 1G 的記憶體空間中，在 896MB 之後的 128MB 屬於 ZONE_HIGHMEM，保留給核心以動態映射的方式映射
high memory。 所以，放在這區的資料基本上是屬於間接存取，必須先完成映射後才能被存取。&lt;/p&gt;
&lt;p&gt;ZONE_DMA 和 ZONE_HIGHMEM 不一定要存在，像 x86_64 就沒有 ZONE_HIGHMEM。除了 x86_32 以外，大部份的系統都只有 ZONE_NORMAL，因為現在的大部份裝置都沒有 DMA 定址的限制，所以就不需要 ZONE_DMA，而64位元系統沒有 4GB 的定址限制，因此 ZONE_HIGHMEM 就不需要了，而就算是 32位元系統，如果不打算配備到 4GB 以上的記憶體，也不需要使用 high memory。&lt;/p&gt;
&lt;p&gt;如果核心有設 high memory 配置的話 (CONFIG_HIGHMEM)，page_address_init() 會負責初始化
high memory 的映射表；若沒有 high memory 配置，page_address_init() 就只是個空函式。&lt;/p&gt;
&lt;blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#if defined(HASHED_PAGE_VIRTUAL)&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;page_address&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;page&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;page&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;set_page_address&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;page&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;page&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;virtual&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;page_address_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;

&lt;span class="cp"&gt;#if !defined(HASHED_PAGE_VIRTUAL) &amp;amp;&amp;amp; !defined(WANT_PAGE_VIRTUAL)&lt;/span&gt;
&lt;span class="cp"&gt;#define page_address(page) lowmem_page_address(page)&lt;/span&gt;
&lt;span class="cp"&gt;#define set_page_address(page, address)  do { } while(0)&lt;/span&gt;
&lt;span class="cp"&gt;#define page_address_init()  do { } while(0)&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#if defined(HASHED_PAGE_VIRTUAL)&lt;/span&gt;

&lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;omitted&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;

&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;__init&lt;/span&gt; &lt;span class="n"&gt;page_address_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;ARRAY_SIZE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;page_address_htable&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;INIT_LIST_HEAD&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;page_address_htable&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;lh&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;spin_lock_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;page_address_htable&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cp"&gt;#endif  &lt;/span&gt;&lt;span class="cm"&gt;/* defined(CONFIG_HIGHMEM) &amp;amp;&amp;amp; !defined(WANT_PAGE_VIRTUAL) */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="memory-architecture"&gt;
&lt;h3&gt;Memory architecture&lt;/h3&gt;
&lt;p&gt;在現代多處理器的系統中，處理器對記憶體的存取可以分為 UMA (Uniform memory access) 和
NUMA (Non-uniform memory access) 兩種架構。&lt;/p&gt;
&lt;p&gt;在 UMA 架構下，CPU 共用同一個 Bus 存取記憶體，所以同時間只能允許一個 CPU 對 Memory 進行存取。很明顯地，記憶體的存取會是 UMA 架構的一個效能瓶頸。&lt;/p&gt;
&lt;blockquote&gt;
&lt;object data="images/UMA.svg" type="image/svg+xml"&gt;
&lt;/object&gt;
&lt;/blockquote&gt;
&lt;p&gt;為了改善 UMA 架構的記憶體存取瓶頸，NUMA 架構被提出，將 memory 分配到各個 CPU，成為各個 CPU 的
local memory，在 Linux 中稱為一個 node。屬於同一個 node 的 CPU 可以直接存取，不需經由 Bus；只有要存取其他 node 的 memory 時才需要經由 Bus。
從架構上可以理解，與存取 local memory 相比，存取其他 node 的 memory 需要花費較多的時間，不同於 UMA 存取所有的記憶體都花費一樣的時間，所以這樣的架構被稱為 Non-uniform memory access, NUMA。&lt;/p&gt;
&lt;blockquote&gt;
&lt;object data="images/NUMA.svg" type="image/svg+xml"&gt;
&lt;/object&gt;
&lt;/blockquote&gt;
&lt;p&gt;Memory node 在 Linux 核心中由 &lt;a class="reference external" href="http://lxr.free-electrons.com/source/include/linux/mmzone.h?v=4.1#L706"&gt;pg_data_t&lt;/a&gt;
來表示，每個 node 包含一到數個 &lt;a class="reference external" href="http://lxr.free-electrons.com/source/include/linux/mmzone.h?v=4.1#L327"&gt;struct zone&lt;/a&gt; ，由各個架構所提供的 setup_arch() 完成初始化。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.kernel.org/doc/Documentation/vm/numa"&gt;https://www.kernel.org/doc/Documentation/vm/numa&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.cc.ntu.edu.tw/chinese/epaper/0015/20101220_1508.htm"&gt;多核心計算環境—NUMA與CPUSET簡介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://software.intel.com/en-us/articles/optimizing-applications-for-numa"&gt;Intel: Optimizing Applications for NUMA&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="setup-arch"&gt;
&lt;h3&gt;setup_arch()&lt;/h3&gt;
&lt;p&gt;setup_arch() 通常被定義在各個架構的 arch/xxx/kernel/setup.c 之內，負責與硬體架構相關的初始化設定，如 CPU, 記憶體, 中斷, I/O, DMA 等。 由於硬體設計不同，特性不同，應用不同，每個架構需要被初始化及設置的硬體及設置的方式都不相同，要了解這個函式必須要對目標架構的硬體特性有相當的了解。&lt;/p&gt;
&lt;p&gt;不同架構的 setup_arch() 差異相當大，像 x86 架構支援功能多，硬體複雜度相對高，連帶它的 setup_arch() 也相對複雜，接近 400 多行，比 start_kernel() 還大；但 arm 架構的 setup_arch() 大概只有 70 多行，相對簡單許多。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://lxr.free-electrons.com/source/arch/x86/kernel/setup.c?v=4.1#L861"&gt;arch/x86/kernel/setup.c: setup_arch()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://lxr.free-electrons.com/source/arch/arm/kernel/setup.c?v=4.1#L913"&gt;arch/arm/kernel/setup.c: setup_arch()&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要深入探討 setup_arch() 必須先說明目標架構的硬體，那須要另外寫一篇才有辦法講清楚，本篇的目標在探討 start_kernel()，不打算深入各別硬體架構的部份。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="mm-init-cpumask"&gt;
&lt;h3&gt;mm_init_cpumask()&lt;/h3&gt;
&lt;p&gt;這個函式很單純，就是把 mm_struct 裡的 cpu_vm_mask_var 初始化為 0，它記錄與這個 mm_struct 有相關的 CPU。&lt;/p&gt;
&lt;blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;mm_init_cpumask&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;mm_struct&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;mm&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="cp"&gt;#ifdef CONFIG_CPUMASK_OFFSTACK&lt;/span&gt;
    &lt;span class="n"&gt;mm&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;cpu_vm_mask_var&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;mm&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;cpumask_allocation&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;
    &lt;span class="n"&gt;cpumask_clear&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mm&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;cpu_vm_mask_var&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 OS 內部有一份記憶體映射表，用以將虛擬記憶體頁對應到實際的物理記憶體頁。
當每次存取虛擬記憶體位址時，都必須參照這份記憶體映射表，找到真正對應的物理記憶體位址。
這份記憶體映射表存放於記憶體中，但記憶體的存取速度跟不上 CPU 的速度，為了加速存取，CPU 內部有一份快取，稱為 TLB (Translation Lookaside Buffer)，CPU 會先看看 TLB 裡面有沒有要查找的位址，若沒有就需要去讀取記憶體中的映射表。&lt;/p&gt;
&lt;p&gt;當記憶體映射表有更動用時，相關 CPU 的 TLB 也需要被更新 (flush)，
cpu_vm_mask_var 記錄了那些 CPU 需要被通知。
這個變數主要會經由 mm_cpumask() 這個 inline 函式存取:&lt;/p&gt;
&lt;blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/* Future-safe accessor for struct mm_struct&amp;#39;s cpu_vm_mask. */&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kr"&gt;inline&lt;/span&gt; &lt;span class="kt"&gt;cpumask_t&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;mm_cpumask&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;mm_struct&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;mm&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;mm&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;cpu_vm_mask_var&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Translation_lookaside_buffer"&gt;https://en.wikipedia.org/wiki/Translation_lookaside_buffer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://pages.cs.wisc.edu/~bart/537/lecturenotes/s17.html"&gt;http://pages.cs.wisc.edu/~bart/537/lecturenotes/s17.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="setup-command-line"&gt;
&lt;h3&gt;setup_command_line()&lt;/h3&gt;
&lt;blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt; * We need to store the untouched command line for future reference.&lt;/span&gt;
&lt;span class="cm"&gt; * We also need to store the touched command line since the parameter&lt;/span&gt;
&lt;span class="cm"&gt; * parsing is performed in place, and we should allow a component to&lt;/span&gt;
&lt;span class="cm"&gt; * store reference of name/value for future reference.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;__init&lt;/span&gt; &lt;span class="nf"&gt;setup_command_line&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;command_line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;saved_command_line&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
        &lt;span class="n"&gt;memblock_virt_alloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;strlen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;boot_command_line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;initcall_command_line&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;
        &lt;span class="n"&gt;memblock_virt_alloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;strlen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;boot_command_line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;static_command_line&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;memblock_virt_alloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;strlen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;command_line&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;strcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;saved_command_line&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;boot_command_line&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;strcpy&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;static_command_line&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;command_line&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;p&gt;setup_command_line() 很單純，它先經由 memblock_virt_alloc() 配置記憶體，然後將
boot_command_line 和 command_line 拷貝到剛剛分配的記憶體存下來。&lt;/p&gt;
&lt;p&gt;memblock 是一個簡單的記憶體管理機制，主要用於 Linux 核心啟動時，當完整的的記憶體管理架構尚未建立時，用來應付記憶體分配的需求。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://0xax.gitbooks.io/linux-insides/content/mm/linux-mm-1.html"&gt;https://0xax.gitbooks.io/linux-insides/content/mm/linux-mm-1.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.maxwellxxx.com/linuxmemblock"&gt;Linux 内核初期内存管理---memblock&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="setup-nr-cpu-ids"&gt;
&lt;h3&gt;setup_nr_cpu_ids()&lt;/h3&gt;
&lt;p&gt;由 cpumask 最後一個 bit 的位置計算目前 CPU 的數目 (nr = number)。&lt;/p&gt;
&lt;blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/* An arch may set nr_cpu_ids earlier if needed, so this would be redundant */&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;__init&lt;/span&gt; &lt;span class="nf"&gt;setup_nr_cpu_ids&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;nr_cpu_ids&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;find_last_bit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cpumask_bits&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cpu_possible_mask&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;NR_CPUS&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="setup-per-cpu-areas"&gt;
&lt;h3&gt;setup_per_cpu_areas()&lt;/h3&gt;
&lt;p&gt;per-CPU area 顧名思義就是每個 CPU 專屬的記憶體區域。 setup_per_cpu_areas()
就是在為每個 CPU 配置它們個別專屬的記憶體區域。那為什麼要為每個 CPU 配置它們個別專屬的記憶體區域？&lt;/p&gt;
&lt;p&gt;在 Linux 核心中有許多的計數器 (counter)，像網路封包的統計，一般最直覺的實作方式就是設置一個公共變數，收到封包時就加一，這個變數通常使用 int 型別，配合 atomic operation (原子操作)減少同步操作的開銷。
在單 CPU 的系統上 (uni-processor, UP)，這樣是很合理的設計，但在多 CPU 的系統上
(symmetric multiple processors，SMP)，這樣的設計會造成兩個問題:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;atomic operation 需要把 memory 的特定區域或是 bus 鎖住，以免其他 CPU 干擾讀寫的動作。&lt;/li&gt;
&lt;li&gt;由於這個變數常常被更動，所以 CPU 的 cache 常常需要被更新 (cache line bouncing)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;為了改善這兩個問題，Linux 核心使用 per-CPU variable 的設計。被宣告為 per-CPU variable
的變數會被配置在每個 CPU 的專屬的記憶體區域，每個 CPU 都只存取自已專屬的變數。以上面所提的網路封包計數的例子來說，每個 CPU 只計數自已看到的封包，當要知道封包計數時只需把每個 CPU 的計數加總起來。&lt;/p&gt;
&lt;p&gt;這樣的設計減少了同步操作的要求，每個 CPU 各自有一份自已的變數資料，彼此之間互相不干擾；也因為 CPU 各自有擁有一份自已的資料，不會產生 cache line bouncing 影響 cache 的效率。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://lwn.net/Articles/170003/"&gt;LWN: The search for fast, scalable counters&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://lwn.net/Articles/258238/"&gt;LWN: Better per-CPU variables&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://0xax.gitbooks.io/linux-insides/content/Concepts/per-cpu.html"&gt;Inside Linux: Per-CPU variables&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="build-all-zonelists"&gt;
&lt;h3&gt;build_all_zonelists()&lt;/h3&gt;
&lt;p&gt;zonelist 代表了一個優先級序列，表示記憶體分配在 zone 中嘗試的順序，當目前的 zone 已無空的記憶體時，會從 zonelist 中找到下一個有可分配記憶體的 zone。build_all_zonelists() 負責設定 &lt;a class="reference external" href="http://lxr.free-electrons.com/source/include/linux/mmzone.h?v=4.1#L706"&gt;pg_data_t&lt;/a&gt; 中的 node_zonelists。&lt;/p&gt;
&lt;p&gt;zonelist 的順序有 2 種選擇:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;ZONELIST_ORDER_NODE : 以 node 為主排序，著重在 memory locality。&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
e.g. node(0).ZONE_MOVABLE, node(0).ZONE_HIGHMEM, node(0).ZONE_NORMAL, node(0).ZONE_DMA,
     node(1).ZONE_MOVABLE, node(1).ZONE_HIGHMEM, node(1).ZONE_NORMAL, node(1).ZONE_DMA,
     ...
&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;ZONELIST_ORDER_ZONE : 以 zone 為主排序，優先尋找相同的型態 zone。&lt;/p&gt;
&lt;pre class="code literal-block"&gt;
e.g. node(0).ZONE_MOVABLE, node(1).ZONE_MOVABLE, ...,
     node(0).ZONE_HIGHMEM, node(1).ZONE_HIGHMEM, ...,
     node(0).ZONE_NORMAL, node(1).ZONE_NORMAL, ...,
     node(0).ZONE_DMA, node(1).ZONE_DMA, ...
&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;numa_zonelist_order 可以由 bootloader 傳給核心 (屬於 early_param)，或經由設定 /proc/sys/vm/numa_zonelist_order 動態改變 zonelist order。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="page-alloc-init"&gt;
&lt;h3&gt;page_alloc_init()&lt;/h3&gt;
&lt;p&gt;page_alloc_init() 只是很單純地註冊一個關於 CPU 熱插拔事件處理的 callback function。由它所註冊的 page_alloc_cpu_notify() 來看，主要是關於 CPU 被動態移除後的相關處理。&lt;/p&gt;
&lt;blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;__init&lt;/span&gt; &lt;span class="nf"&gt;page_alloc_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;hotcpu_notifier&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;page_alloc_cpu_notify&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;page_alloc_cpu_notify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;notifier_block&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                 &lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;hcpu&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;cpu&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;unsigned&lt;/span&gt; &lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;hcpu&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;action&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;CPU_DEAD&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;action&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;CPU_DEAD_FROZEN&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;lru_add_drain_cpu&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cpu&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;drain_pages&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cpu&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;         * Spill the event counters of the dead processor&lt;/span&gt;
&lt;span class="cm"&gt;         * into the current processors event counters.&lt;/span&gt;
&lt;span class="cm"&gt;         * This artificially elevates the count of the current&lt;/span&gt;
&lt;span class="cm"&gt;         * processor.&lt;/span&gt;
&lt;span class="cm"&gt;         */&lt;/span&gt;
        &lt;span class="n"&gt;vm_events_fold_cpu&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cpu&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;         * Zero the differential counters of the dead processor&lt;/span&gt;
&lt;span class="cm"&gt;         * so that the vm statistics are consistent.&lt;/span&gt;
&lt;span class="cm"&gt;         *&lt;/span&gt;
&lt;span class="cm"&gt;         * This is only okay since the processor is dead and cannot&lt;/span&gt;
&lt;span class="cm"&gt;         * race with what we are doing.&lt;/span&gt;
&lt;span class="cm"&gt;         */&lt;/span&gt;
        &lt;span class="n"&gt;cpu_vm_stats_fold&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cpu&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;NOTIFY_OK&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="reference"&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.slideshare.net/shimosawa/linux-initialization-process-2"&gt;http://www.slideshare.net/shimosawa/linux-initialization-process-2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://0xax.gitbooks.io/linux-insides/content/Initialization/index.html"&gt;gitbook: Linux Insides: Kernel initialization process&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://github.com/torvalds/linux/blame/v4.1/init/main.c#L492"&gt;init/main.c: start_kernel()&lt;/a&gt; (git blame, 可以查看程式碼的改動記錄以及原因)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Kernel Documentation:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;x86 boot protocol: &lt;a class="reference external" href="https://www.kernel.org/doc/Documentation/x86/boot.txt"&gt;https://www.kernel.org/doc/Documentation/x86/boot.txt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;arm booting: &lt;a class="reference external" href="https://www.kernel.org/doc/Documentation/arm/Booting"&gt;https://www.kernel.org/doc/Documentation/arm/Booting&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Daniel Lin</dc:creator><pubDate>Mon, 16 May 2016 00:00:00 +0800</pubDate><guid>tag:danielmaker.github.io,2016-05-16:blog/linux/inside_start_kernel.html</guid><category>Linux kernel</category></item><item><title>核心的進入點: start_kernel()</title><link>https://danielmaker.github.io/blog/linux/start_kernel.html</link><description>&lt;!-- ............................................................................. --&gt;
&lt;style type="text/css"&gt;
    .red    { color: red;   }
    .blue   { color: blue;  }
    .red-b  { color: red;  font-weight: bold; }
    .blue-b { color: blue; font-weight: bold; }
    .green  { color: green;  }
    .gray   { color: gray;  }
    .diagram {line-height: 1;}
&lt;/style&gt;&lt;!-- ............................................................................. --&gt;
&lt;!--  --&gt;
&lt;blockquote&gt;
&lt;object class="diagram" data="https://danielmaker.github.io/blog/linux/images/start_kernel_call_graph.svg" style="width: 100%;" type="image/svg+xml"&gt;
&lt;/object&gt;
&lt;a style="font-size: 75%;" href="https://danielmaker.github.io/blog/linux/images/start_kernel_call_graph.svg"&gt;larger call graph&lt;/a&gt;&lt;/blockquote&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;start_kernel&lt;/h2&gt;
&lt;p&gt;start_kernel() 是 Linux kernel &amp;quot;正式的&amp;quot;進入點，但是 start_kernel()
通常不是在核心被載入後就立刻被執行，在它開始執行之前還有些準備工作要先完成。
在核心被載入後，通常最開始被執行的是的放在 Linux kernel image 最開頭的 bootstrap code, 負責關閉中斷，記憶體設定等硬體初始化準備工作，甚至還包含將壓縮的內核解壓縮。
這些 bootstrap code 是屬於平台架構相依的，它通常是位於 arch/xxx/boot/ 之下的 assembly code
(xxx 可以是 x86 或是 arm 等)。嚴格來說，這些 bootstrap code 並不能算是 Linux kernel 的一部份，
它們在完成核心載入的任務之後就不需要了，在這之後才是開始執行 start_kernel()，開始屬於核心層級的初始化流程。&lt;/p&gt;
&lt;p&gt;簡單來說，在機器啟動(power on)之後的開機流程通常會是:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;Bootloader 將 kernel image 載入到記憶體之中。&lt;/li&gt;
&lt;li&gt;在 kernel image 前段的 bootstrap code 進行硬體初始化等準備工作，並將內核解壓縮。&lt;/li&gt;
&lt;li&gt;最後呼叫 &lt;a class="reference external" href="http://lxr.free-electrons.com/source/init/main.c?v=4.1#L492"&gt;start_kernel()&lt;/a&gt;，開始一連串真正屬於 kernel level 的初始化工作。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;start_kernel() 本身是個非常龐大的函式，主要的 OS 資料結構，基礎設施及子系統都由這邊進行初始化，在追蹤 start_kernel() 的過程中能夠看到 OS 的全貌。
因為如此，所以我覺得想要了解 Linux kernel 的話，start_kernel() 是一個非常好的進入點。&lt;/p&gt;
&lt;p&gt;本篇先不深入 start_kernel() 的細節，先給一個關於核心初始化流程的概觀。
在本篇最開始的地方有一張 call graph，經由這張圖我們可以概略地了解 start_kernel() 之後的流程：&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p class="first"&gt;呼叫 setup_arch() 進行架構相關的初始化。&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="http://lxr.free-electrons.com/ident?v=4.1;i=setup_arch"&gt;setup_arch()&lt;/a&gt; 是由各個架構提供，通常是在 arch/xxx/kernel/setup.c 之中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;設定中斷向量，初始化記憶體管理 (memory management), 排程器 (scheduler), 虛擬檔案系統 (virtual file system), ... 等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;在 start_kernel() 的最後會呼叫 rest_init()，到此已經完成了 OS 最核心部份的初始化，基本上 OS 已經算可以動了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;rest_init() 就字面上的意義是&amp;quot;其餘的初始化工作&amp;quot;，它會呼叫兩次 kernel_thread() 產生另外兩個核心程序 kernel_init 及 kthreadd，最後它會進入 cpu_idle_loop() 之中成為 pid = 0 的 idle process。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;pid = 1 的 kernel_init 會繼續更高階的初始化，如初始化 driver, 打開 console, 最後根據不同的系統配置，
執行對應的初始化腳本 (可能是 /linuxrc 或是 /init)，或者是下列任一個預設的 init 程序，完成整個系統的初始化。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;/sbin/init&lt;/li&gt;
&lt;li&gt;/etc/init&lt;/li&gt;
&lt;li&gt;/bin/init&lt;/li&gt;
&lt;li&gt;/bin/sh (最後的這個 sh 程序是當系統出問題時作為系統修復使用)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;pid = 2 的 kthreadd 是一個核心守護線程 (daemon thread)，它是所有其他核心守護線程的父線程，負責處理其他核心線程創建請求。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接下來，讓我們來實際看看程式碼 (kernel version 4.1.15)。為了說明方便，下面的內核程式碼會有些簡化。&lt;/p&gt;
&lt;p&gt;linux/init/main.c : &lt;a class="reference external" href="http://lxr.free-electrons.com/source/init/main.c?v=4.1#L492"&gt;start_kernel()&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在 bootloader 將 kernel image 載入並解壓縮到記憶體，完成必要的硬體設定，及初始記憶體分頁後，&lt;a class="reference external" href="http://lxr.free-electrons.com/source/init/main.c?v=4.1#L492"&gt;start_kernel()&lt;/a&gt; 將會被呼叫，開始進行核心層級的初始化。&lt;/p&gt;
&lt;blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;asmlinkage&lt;/span&gt; &lt;span class="n"&gt;__visible&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;__init&lt;/span&gt; &lt;span class="nf"&gt;start_kernel&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;command_line&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;kernel_param&lt;/span&gt; &lt;span class="n"&gt;__start___param&lt;/span&gt;&lt;span class="p"&gt;[],&lt;/span&gt; &lt;span class="n"&gt;__stop___param&lt;/span&gt;&lt;span class="p"&gt;[];&lt;/span&gt;

    &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt; &lt;span class="n"&gt;procedures&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;omitted&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;

    &lt;span class="n"&gt;boot_cpu_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="hll"&gt;    &lt;span class="n"&gt;setup_arch&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;command_line&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;         &lt;span class="c1"&gt;// architecture-specific setup&lt;/span&gt;
&lt;/span&gt;    &lt;span class="n"&gt;setup_command_line&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;command_line&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;// store the untouched command line&lt;/span&gt;

    &lt;span class="n"&gt;trap_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  &lt;span class="c1"&gt;// architecture-specific, interrupt vector table, handle hardware traps, exceptions and faults.&lt;/span&gt;
&lt;span class="hll"&gt;    &lt;span class="n"&gt;mm_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;    &lt;span class="c1"&gt;// memory management&lt;/span&gt;
&lt;/span&gt;

    &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;     * Set up the scheduler prior starting any interrupts (such as the&lt;/span&gt;
&lt;span class="cm"&gt;     * timer interrupt). Full topology setup happens at smp_init()&lt;/span&gt;
&lt;span class="cm"&gt;     * time - but meanwhile we still have a functioning scheduler.&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
&lt;span class="hll"&gt;    &lt;span class="n"&gt;sched_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/span&gt;
    &lt;span class="n"&gt;init_IRQ&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;tick_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;init_timers&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt; &lt;span class="n"&gt;procedures&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;omitted&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;


    &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;     * HACK ALERT! This is early. We&amp;#39;re enabling the console before&lt;/span&gt;
&lt;span class="cm"&gt;     * we&amp;#39;ve done PCI setups etc, and console_init() must be aware of&lt;/span&gt;
&lt;span class="cm"&gt;     * this. But we do want output early, in case something goes wrong.&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="n"&gt;console_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt; &lt;span class="n"&gt;procedures&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;omitted&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;


    &lt;span class="n"&gt;sched_clock_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt; &lt;span class="n"&gt;procedures&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;omitted&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;


&lt;span class="hll"&gt;    &lt;span class="n"&gt;vfs_caches_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;totalram_pages&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;  &lt;span class="c1"&gt;// file system, including kernfs, sysfs, rootfs, mount tree&lt;/span&gt;
&lt;/span&gt;
&lt;span class="hll"&gt;    &lt;span class="n"&gt;proc_root_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  &lt;span class="c1"&gt;// /proc, /proc/fs, /proc/driver, ...&lt;/span&gt;
&lt;/span&gt;    &lt;span class="n"&gt;nsfs_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;cpuset_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;cgroup_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt; &lt;span class="n"&gt;procedures&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;omitted&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;


    &lt;span class="cm"&gt;/* Do the rest non-__init&amp;#39;ed, we&amp;#39;re now alive */&lt;/span&gt;
    &lt;span class="n"&gt;rest_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;p&gt;到這邊，屬於 OS 最核心的的基礎設施都已經完成初始化，基本上 OS 已經可以開始作用了。接下來在 start_kernel()
的最後會呼叫 &lt;a class="reference external" href="http://lxr.free-electrons.com/source/init/main.c?v=4.1#L383"&gt;rest_init()&lt;/a&gt; ，它會產生另一個核心程序 kernel_init，繼續更高階系統的初始化。&lt;/p&gt;
&lt;p&gt;在 rest_init() 中主要進行 4 件工作:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;創建核心線程 kernel_init&lt;/li&gt;
&lt;li&gt;創建核心線程 kthreadd&lt;/li&gt;
&lt;li&gt;至少執行一次 schedule() 進行排程調度，讓剛剛創建的核心線程能夠開始執行&lt;/li&gt;
&lt;li&gt;進入 cpu_idle_loop() 變成 idle process (pid=0) 處理 idle task&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;noinline&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;__init_refok&lt;/span&gt; &lt;span class="nf"&gt;rest_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;rcu_scheduler_starting&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;smpboot_thread_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;     * We need to spawn init first so that it obtains pid 1, however&lt;/span&gt;
&lt;span class="cm"&gt;     * the init task will end up wanting to create kthreads, which, if&lt;/span&gt;
&lt;span class="cm"&gt;     * we schedule it before we create kthreadd, will OOPS.&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
&lt;span class="hll"&gt;    &lt;span class="n"&gt;kernel_thread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;kernel_init&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;CLONE_FS&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;    &lt;span class="n"&gt;numa_default_policy&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="hll"&gt;    &lt;span class="n"&gt;pid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;kernel_thread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;kthreadd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;CLONE_FS&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;CLONE_FILES&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;    &lt;span class="n"&gt;rcu_read_lock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;kthreadd_task&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;find_task_by_pid_ns&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pid&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;init_pid_ns&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;rcu_read_unlock&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;complete&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;kthreadd_done&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// for synchronization. kernel_init_freeable() will wait for this signal&lt;/span&gt;

    &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;     * The boot idle thread must execute schedule()&lt;/span&gt;
&lt;span class="cm"&gt;     * at least once to get things moving:&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="n"&gt;init_idle_bootup_task&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// set its scheduling class to idle_sched_class&lt;/span&gt;
    &lt;span class="n"&gt;schedule_preempt_disabled&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;    &lt;span class="c1"&gt;// this function will call schedule()&lt;/span&gt;

    &lt;span class="cm"&gt;/* Call into cpu_idle with preempt disabled \*/&lt;/span&gt;
    &lt;span class="n"&gt;cpu_startup_entry&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CPUHP_ONLINE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * schedule_preempt_disabled - called with preemption disabled&lt;/span&gt;
&lt;span class="cm"&gt; *&lt;/span&gt;
&lt;span class="cm"&gt; * Returns with preemption disabled. Note: preempt_count must be 1&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;__sched&lt;/span&gt; &lt;span class="nf"&gt;schedule_preempt_disabled&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;sched_preempt_enable_no_resched&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  &lt;span class="c1"&gt;// Enables kernel preemption but do not check for any pending reschedules&lt;/span&gt;
&lt;span class="hll"&gt;    &lt;span class="n"&gt;schedule&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/span&gt;    &lt;span class="n"&gt;preempt_disable&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  &lt;span class="c1"&gt;// Disables kernel preemption by incrementing the preemption counter&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;cpu_startup_entry&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="n"&gt;cpuhp_state&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="p"&gt;...&lt;/span&gt; &lt;span class="n"&gt;omitted&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;

    &lt;span class="n"&gt;arch_cpu_idle_prepare&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;cpu_idle_loop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="idle-loop-pid-0"&gt;
&lt;h2&gt;idle loop (pid=0)&lt;/h2&gt;
&lt;p&gt;rest_init() 在最後會進入 cpu_idle_loop() 之中成為 pid = 0 的 idle process，到這邊它已經完成系統初始化的任務了。&lt;/p&gt;
&lt;p&gt;idle process 的優先權是最低的，當 CPU 真的沒事做時才會輪到它。在 x86 的架構下，會執行 CPU hlt 指令，在 ARM 架構下則是 wfe 指令 (wait for event)，讓 CPU 進入睡眠。&lt;/p&gt;
&lt;p&gt;kernel/sched/idle.c: &lt;a class="reference external" href="http://lxr.free-electrons.com/source/kernel/sched/idle.c?v=4.1#L207"&gt;cpu_idle_loop()&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;cpu_idle_loop&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;         * If the arch has a polling bit, we maintain an invariant:&lt;/span&gt;
&lt;span class="cm"&gt;         *&lt;/span&gt;
&lt;span class="cm"&gt;         * Our polling bit is clear if we&amp;#39;re not scheduled (i.e. if&lt;/span&gt;
&lt;span class="cm"&gt;         * rq-&amp;gt;curr != rq-&amp;gt;idle).  This means that, if rq-&amp;gt;idle has&lt;/span&gt;
&lt;span class="cm"&gt;         * the polling bit set, then setting need_resched is&lt;/span&gt;
&lt;span class="cm"&gt;         * guaranteed to cause the cpu to reschedule.&lt;/span&gt;
&lt;span class="cm"&gt;         */&lt;/span&gt;

        &lt;span class="n"&gt;__current_set_polling&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;tick_nohz_idle_enter&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;   &lt;span class="c1"&gt;// stop the idle tick from the idle task&lt;/span&gt;

        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;need_resched&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;check_pgt_cache&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="n"&gt;rmb&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;      &lt;span class="c1"&gt;// read memory barrier.&lt;/span&gt;
                        &lt;span class="c1"&gt;// It ensures that no loads are reordered across the rmb() call.&lt;/span&gt;
                        &lt;span class="c1"&gt;// no loads prior to the call will be reordered to after the call&lt;/span&gt;
                        &lt;span class="c1"&gt;// and no loads after the call will be reordered to before the call.&lt;/span&gt;
                        &lt;span class="c1"&gt;// http://www.makelinux.net/books/lkd2/ch09lev1sec10&lt;/span&gt;

            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cpu_is_offline&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;smp_processor_id&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;rcu_cpu_notify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;CPU_DYING_IDLE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                           &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;long&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;smp_processor_id&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
                &lt;span class="n"&gt;smp_mb&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="cm"&gt;/* all activity before dead. */&lt;/span&gt;
                &lt;span class="n"&gt;this_cpu_write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cpu_dead_idle&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="n"&gt;arch_cpu_idle_dead&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;

            &lt;span class="n"&gt;local_irq_disable&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="n"&gt;arch_cpu_idle_enter&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

            &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;             * In poll mode we reenable interrupts and spin.&lt;/span&gt;
&lt;span class="cm"&gt;             *&lt;/span&gt;
&lt;span class="cm"&gt;             * Also if we detected in the wakeup from idle&lt;/span&gt;
&lt;span class="cm"&gt;             * path that the tick broadcast device expired&lt;/span&gt;
&lt;span class="cm"&gt;             * for us, we don&amp;#39;t want to go deep idle as we&lt;/span&gt;
&lt;span class="cm"&gt;             * know that the IPI is going to arrive right&lt;/span&gt;
&lt;span class="cm"&gt;             * away&lt;/span&gt;
&lt;span class="cm"&gt;             */&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cpu_idle_force_poll&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;tick_check_broadcast_expired&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt;
                &lt;span class="n"&gt;cpu_idle_poll&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;
                &lt;span class="n"&gt;cpuidle_idle_call&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

            &lt;span class="n"&gt;arch_cpu_idle_exit&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;         * Since we fell out of the loop above, we know&lt;/span&gt;
&lt;span class="cm"&gt;         * TIF_NEED_RESCHED must be set, propagate it into&lt;/span&gt;
&lt;span class="cm"&gt;         * PREEMPT_NEED_RESCHED.&lt;/span&gt;
&lt;span class="cm"&gt;         *&lt;/span&gt;
&lt;span class="cm"&gt;         * This is required because for polling idle loops we will&lt;/span&gt;
&lt;span class="cm"&gt;         * not have had an IPI to fold the state for us.&lt;/span&gt;
&lt;span class="cm"&gt;         */&lt;/span&gt;
        &lt;span class="n"&gt;preempt_set_need_resched&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="n"&gt;tick_nohz_idle_exit&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;   &lt;span class="c1"&gt;// restart the idle tick from the idle task&lt;/span&gt;
        &lt;span class="n"&gt;__current_clr_polling&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

        &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;         * We promise to call sched_ttwu_pending and reschedule&lt;/span&gt;
&lt;span class="cm"&gt;         * if need_resched is set while polling is set.  That&lt;/span&gt;
&lt;span class="cm"&gt;         * means that clearing polling needs to be visible&lt;/span&gt;
&lt;span class="cm"&gt;         * before doing these things.&lt;/span&gt;
&lt;span class="cm"&gt;         */&lt;/span&gt;
        &lt;span class="n"&gt;smp_mb__after_atomic&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

        &lt;span class="n"&gt;sched_ttwu_pending&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="hll"&gt;        &lt;span class="n"&gt;schedule_preempt_disabled&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/span&gt;    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * schedule_preempt_disabled - called with preemption disabled&lt;/span&gt;
&lt;span class="cm"&gt; *&lt;/span&gt;
&lt;span class="cm"&gt; * Returns with preemption disabled. Note: preempt_count must be 1&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;__sched&lt;/span&gt; &lt;span class="nf"&gt;schedule_preempt_disabled&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;sched_preempt_enable_no_resched&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  &lt;span class="c1"&gt;// Enables kernel preemption but do not check for any pending reschedules&lt;/span&gt;
&lt;span class="hll"&gt;    &lt;span class="n"&gt;schedule&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/span&gt;    &lt;span class="n"&gt;preempt_disable&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  &lt;span class="c1"&gt;// Disables kernel preemption by incrementing the preemption counter&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="kernel-init-pid-1"&gt;
&lt;h2&gt;kernel_init (pid=1)&lt;/h2&gt;
&lt;p&gt;kernel_init 會繼續接手系統層級的初始化工作。一個系統除了 CPU 及記憶體外等核心硬體外，還有許多 I/O 週邊需要 OS 的支援，而除了硬體之外，還有像檔案系統，網路協議處理等屬於軟體中間層的部份需要 OS 的支援。 這些部份的初始化由 kernel_init() 來完成。&lt;/p&gt;
&lt;p&gt;init/main.c : &lt;a class="reference external" href="http://lxr.free-electrons.com/source/init/main.c?v=4.1#L927"&gt;kernel_init()&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;__ref&lt;/span&gt; &lt;span class="nf"&gt;kernel_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;unused&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;ret&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="hll"&gt;    &lt;span class="n"&gt;kernel_init_freeable&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;    &lt;span class="c1"&gt;// init drivers, modules, and open /dev/console&lt;/span&gt;
&lt;/span&gt;    &lt;span class="cm"&gt;/* need to finish all async __init code before freeing the memory */&lt;/span&gt;
    &lt;span class="n"&gt;async_synchronize_full&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  &lt;span class="c1"&gt;// waits until all asynchronous function calls have been done&lt;/span&gt;
    &lt;span class="n"&gt;free_initmem&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;            &lt;span class="c1"&gt;// free .init section from memory&lt;/span&gt;
    &lt;span class="n"&gt;mark_rodata_ro&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;          &lt;span class="c1"&gt;// mark rodata read-only&lt;/span&gt;
    &lt;span class="n"&gt;system_state&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SYSTEM_RUNNING&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;numa_default_policy&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="n"&gt;flush_delayed_fput&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ramdisk_execute_command&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;ret&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;run_init_process&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ramdisk_execute_command&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;ret&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;pr_err&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Failed to execute %s (error %d)&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                   &lt;span class="n"&gt;ramdisk_execute_command&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ret&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;     * We try each of these until one succeeds.&lt;/span&gt;
&lt;span class="cm"&gt;     *&lt;/span&gt;
&lt;span class="cm"&gt;     * The Bourne shell can be used instead of init if we are&lt;/span&gt;
&lt;span class="cm"&gt;     * trying to recover a really broken machine.&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;execute_command&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;ret&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;run_init_process&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;execute_command&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;ret&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="cp"&gt;#ifndef CONFIG_INIT_FALLBACK&lt;/span&gt;
            &lt;span class="n"&gt;panic&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Requested init %s failed (error %d).&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                  &lt;span class="n"&gt;execute_command&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ret&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="cp"&gt;#else&lt;/span&gt;
            &lt;span class="n"&gt;pr_err&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Failed to execute %s (error %d).  Attempting defaults...&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                   &lt;span class="n"&gt;execute_command&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ret&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="cp"&gt;#endif&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;try_to_run_init_process&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;/sbin/init&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt;
        &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;try_to_run_init_process&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;/etc/init&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt;
        &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;try_to_run_init_process&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;/bin/init&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt;
        &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;try_to_run_init_process&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;/bin/sh&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;panic&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;No working init found.  Try passing init= option to kernel. &amp;quot;&lt;/span&gt;
          &lt;span class="s"&gt;&amp;quot;See Linux Documentation/init.txt for guidance.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;p&gt;init/main.c: &lt;a class="reference external" href="http://lxr.free-electrons.com/source/init/main.c?v=4.1#L972"&gt;kernel_init_freeable()&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;freeable 就字面上的意思是可以被卸載的，這個函式主要是將一些系統週邊及軟體中間層掛進 OS 及初始化。
kernel_init_freeable() 所處理的初始化工作非常廣，如下面的程式碼所表示，它包含初始化 device, driver, rootfs, 掛載 /dev, /sys 等虛擬檔案系統目錄，開啟 /dev/console 做為訊息輸出等。
它的大部份的工作都是由 do_basic_setup() 所完成，要深入它需要比較多的時間，在這邊我們先回到比較高階的觀點來看整體初始化的流程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;noinline&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;__init&lt;/span&gt; &lt;span class="nf"&gt;kernel_init_freeable&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;     * Wait until kthreadd is all set-up.&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="n"&gt;wait_for_completion&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;kthreadd_done&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="cm"&gt;/* Now the scheduler is fully set up and can do blocking allocations */&lt;/span&gt;
    &lt;span class="n"&gt;gfp_allowed_mask&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;__GFP_BITS_MASK&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;     * init can allocate pages on any node&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="n"&gt;set_mems_allowed&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node_states&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;N_MEMORY&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;     * init can run on any cpu.&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="n"&gt;set_cpus_allowed_ptr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cpu_all_mask&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;cad_pid&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;task_pid&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;smp_prepare_cpus&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;setup_max_cpus&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;do_pre_smp_initcalls&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;lockup_detector_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="n"&gt;smp_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;sched_init_smp&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

&lt;span class="hll"&gt;    &lt;span class="n"&gt;do_basic_setup&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;/span&gt;
    &lt;span class="cm"&gt;/* Open the /dev/console on the rootfs, this should never fail */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sys_open&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;__user&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;/dev/console&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;O_RDWR&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;pr_err&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Warning: unable to open an initial console.&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;sys_dup&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;sys_dup&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;     * check if there is an early userspace init.  If yes, let it do all&lt;/span&gt;
&lt;span class="cm"&gt;     * the work&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;ramdisk_execute_command&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;ramdisk_execute_command&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;/init&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sys_access&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;__user&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;ramdisk_execute_command&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;ramdisk_execute_command&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;prepare_namespace&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;     * Ok, we have completed the initial bootup, and&lt;/span&gt;
&lt;span class="cm"&gt;     * we&amp;#39;re essentially up and running. Get rid of the&lt;/span&gt;
&lt;span class="cm"&gt;     * initmem segments and start the user-mode stuff..&lt;/span&gt;
&lt;span class="cm"&gt;     *&lt;/span&gt;
&lt;span class="cm"&gt;     * rootfs is available now, try loading the public keys&lt;/span&gt;
&lt;span class="cm"&gt;     * and default modules&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;

    &lt;span class="n"&gt;integrity_load_keys&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;load_default_modules&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;p&gt;init/main.c: &lt;a class="reference external" href="http://lxr.free-electrons.com/source/init/main.c?v=4.1#L864"&gt;do_basic_setup()&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;事實上，大部份的初始化工作都在這個函式內完成，do_basic_setup() 絕不簡單。&lt;/p&gt;
&lt;blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt; * Ok, the machine is now initialized. None of the devices&lt;/span&gt;
&lt;span class="cm"&gt; * have been touched yet, but the CPU subsystem is up and&lt;/span&gt;
&lt;span class="cm"&gt; * running, and memory and process management works.&lt;/span&gt;
&lt;span class="cm"&gt; *&lt;/span&gt;
&lt;span class="cm"&gt; * Now we can finally start doing some real work..&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;__init&lt;/span&gt; &lt;span class="nf"&gt;do_basic_setup&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;cpuset_init_smp&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;usermodehelper_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;shmem_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;driver_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;           &lt;span class="c1"&gt;// init driver model. (kobject, kset)&lt;/span&gt;
    &lt;span class="n"&gt;init_irq_proc&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;do_ctors&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;              &lt;span class="c1"&gt;// call constructor functions in .ctors section&lt;/span&gt;
    &lt;span class="n"&gt;usermodehelper_enable&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;do_initcalls&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;          &lt;span class="c1"&gt;// call init functions in .initcall[0~9].init sections&lt;/span&gt;
    &lt;span class="n"&gt;random_int_secret_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt; * driver_init - initialize driver model.&lt;/span&gt;
&lt;span class="cm"&gt; *&lt;/span&gt;
&lt;span class="cm"&gt; * Call the driver model init functions to initialize their&lt;/span&gt;
&lt;span class="cm"&gt; * subsystems. Called early from init/main.c.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;__init&lt;/span&gt; &lt;span class="nf"&gt;driver_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* These are the core pieces */&lt;/span&gt;
    &lt;span class="n"&gt;devtmpfs_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;  &lt;span class="c1"&gt;// mount root node: &amp;quot;/&amp;quot;&lt;/span&gt;
    &lt;span class="n"&gt;devices_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;buses_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;classes_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;firmware_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;hypervisor_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

    &lt;span class="cm"&gt;/* These are also core pieces, but must come after the&lt;/span&gt;
&lt;span class="cm"&gt;     * core core pieces.&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="n"&gt;platform_bus_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;cpu_dev_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;memory_dev_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;container_dev_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;of_core_init&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="kthreadd-pid-2"&gt;
&lt;h2&gt;kthreadd (pid=2)&lt;/h2&gt;
&lt;p&gt;kernel/kthread.c: &lt;a class="reference external" href="http://lxr.free-electrons.com/source/kernel/kthread.c?v=4.1#L483"&gt;kthreadd()&lt;/a&gt;&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;kthreadd 是一個核心守護線程 (daemon thread)，它是所有其他核心線程的父線程。它負責處理經由 &lt;a class="reference external" href="http://lxr.free-electrons.com/source/kernel/kthread.c?v=4.1#L245"&gt;kthread_create_on_node()&lt;/a&gt; 記錄在 &lt;code&gt;kthread_create_list&lt;/code&gt; 的核心線程創建請求。&lt;/li&gt;
&lt;li&gt;當 &lt;code&gt;kthread_create_list&lt;/code&gt; 為空時，kthreadd 會將自已的狀態設為 &lt;code&gt;TASK_INTERRUPTIBLE&lt;/code&gt;，並讓出 CPU。&lt;/li&gt;
&lt;/ul&gt;
&lt;!--  --&gt;
&lt;blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;kthread_create_info&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="cm"&gt;/* Information passed to kthread() from kthreadd. */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;threadfn&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;node&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* Result passed back to kthread_create() from kthreadd. */&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;task_struct&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;completion&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;done&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;list_head&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;kthreadd&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;unused&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;task_struct&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;tsk&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="cm"&gt;/* Setup a clean context for our children to inherit. */&lt;/span&gt;
    &lt;span class="n"&gt;set_task_comm&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tsk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;kthreadd&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;ignore_signals&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tsk&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;set_cpus_allowed_ptr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tsk&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;cpu_all_mask&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;set_mems_allowed&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;node_states&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;N_MEMORY&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;

    &lt;span class="n"&gt;current&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;flags&lt;/span&gt; &lt;span class="o"&gt;|=&lt;/span&gt; &lt;span class="n"&gt;PF_NOFREEZE&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(;;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;set_current_state&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TASK_INTERRUPTIBLE&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;list_empty&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;kthread_create_list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;  &lt;span class="c1"&gt;// if no kthread create request&lt;/span&gt;
&lt;span class="hll"&gt;            &lt;span class="n"&gt;schedule&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;                        &lt;span class="c1"&gt;// yield CPU&lt;/span&gt;
&lt;/span&gt;        &lt;span class="n"&gt;__set_current_state&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TASK_RUNNING&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="n"&gt;spin_lock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;kthread_create_lock&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;list_empty&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;kthread_create_list&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;  &lt;span class="c1"&gt;// handle all kthread create requests&lt;/span&gt;
            &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;kthread_create_info&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;create&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

            &lt;span class="n"&gt;create&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;list_entry&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;kthread_create_list&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;next&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                        &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;kthread_create_info&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;list_del_init&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;create&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;list&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="c1"&gt;// remove the entry from list&lt;/span&gt;
            &lt;span class="n"&gt;spin_unlock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;kthread_create_lock&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="hll"&gt;            &lt;span class="n"&gt;create_kthread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;create&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;
            &lt;span class="n"&gt;spin_lock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;kthread_create_lock&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;spin_unlock&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;kthread_create_lock&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="id3"&gt;
&lt;h2&gt;小結&lt;/h2&gt;
&lt;p&gt;本篇介紹 Linux kernel 在 start_kernel() 之後大致的流程。
在系統開機之後基本上就是一連串的初始化流程，由低階到高階，而高階的部份常常會根據各個系統不同的應用情境進行調整。&lt;/p&gt;
&lt;p&gt;要了解一個系統，我喜歡由巨觀的程式流程入手，然後再深入了解微觀的實作細節，對我來說，這是比較好的順序。
在看實作的細節時，我會想先知道我目前處在整個大架構的什麼位置，資料的上下游關係是什麼，這樣可以讓我比較能理解程式是怎樣運作的，以及實作時的考量。
因此本篇先講核心啟動的大架構流程，接下來將會對 Linux 系統初始化流程的各個部份有更深入的探討。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="reference"&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.ibm.com/developerworks/library/l-linuxboot/index.html"&gt;IBM developerWorks: Inside the Linux boot process&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://duartes.org/gustavo/blog/post/kernel-boot-process/"&gt;Gustavo Duarte: The Kernel Boot Process&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://duartes.org/gustavo/blog/post/what-does-an-idle-cpu-do/"&gt;Gustavo Duarte: What Does an Idle CPU Do?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Kernel doc:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;x86 booting: &lt;a class="reference external" href="https://www.kernel.org/doc/Documentation/x86/boot.txt"&gt;https://www.kernel.org/doc/Documentation/x86/boot.txt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;arm booting: &lt;a class="reference external" href="https://www.kernel.org/doc/Documentation/arm/Booting"&gt;https://www.kernel.org/doc/Documentation/arm/Booting&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Daniel Lin</dc:creator><pubDate>Tue, 12 Jan 2016 00:00:00 +0800</pubDate><guid>tag:danielmaker.github.io,2016-01-12:blog/linux/start_kernel.html</guid><category>Linux kernel</category></item><item><title>Linux Kernel 探險地圖</title><link>https://danielmaker.github.io/blog/linux/linux_kernel_beginning.html</link><description>&lt;!-- ............................................................................. --&gt;
&lt;style type="text/css"&gt;
    .red    { color: red;   }
    .blue   { color: blue;  }
    .red-b  { color: red;  font-weight: bold; }
    .blue-b { color: blue; font-weight: bold; }
    .green  { color: green;  }
    .gray   { color: gray;  }
&lt;/style&gt;&lt;style type="text/css"&gt;

.source-tree
{
    line-height: 100%;
        color: #000000;
        background: #eeeeee;
}

&lt;/style&gt;&lt;!-- ............................................................................. --&gt;
&lt;p&gt;Linux kernel 就像是一個龐大的迷宮，如果沒有適當的引導，常讓想要了解它的新手不知道要如何開始。
所幸，Linux kernel 是指標性的開放源碼專案，有許多的前輩高人留下相當多的資料，也有許多人持續在研究它，並且將成果及心得公開在網路上，這對有心想要了解它的人是很好的參考資料來源。&lt;/p&gt;
&lt;p&gt;雖然網路上已經有許多資料可供參考，但是它們沒辦法也沒必要解答我所有的疑問，許多細節之處必須親身碰過才會有感覺。
像我這樣對 Linux kernel 有與趣，想了解它是如何運作及如何被設計的人，我需要有一份屬於自已的地圖，將我所探險過的地方及心得記錄下來，讓我之後可以快速回顧。&lt;/p&gt;
&lt;p&gt;我把這樣的記錄稱為核心探險地圖，因為對我而言，比起單純的文字，圖表總是更容易把一些關鍵之處連結起來。
當然，為了能和社群互相交流，這樣的記錄最好能夠稍加整理一下，將它分享出來，讓其他像我一樣有興趣的人能夠參考，一起學習，互相交流。&lt;/p&gt;
&lt;p&gt;在出發探險之前，先讓我們看看有什麼資料可以幫助我們。
本篇收集了一些關於學習 Linux kernel 相關的資源。&lt;/p&gt;
&lt;div class="section" id="source-code"&gt;
&lt;h2&gt;Source Code&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;官方網站 The Linux Kernel Archives: &lt;a class="reference external" href="https://kernel.org"&gt;https://kernel.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Github: &lt;a class="reference external" href="https://github.com/torvalds/linux"&gt;https://github.com/torvalds/linux&lt;/a&gt; (這邊應該只是 mirror)&lt;/li&gt;
&lt;li&gt;Linux Cross Reference: &lt;a class="reference external" href="http://lxr.free-electrons.com"&gt;http://lxr.free-electrons.com&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;woboq code browser : &lt;a class="reference external" href="http://code.woboq.org/linux/"&gt;http://code.woboq.org/linux/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在將 Linux kernel source 下載下來之後，第一眼看到的是它的目錄結構，這些目錄代表核心主要的組成元件，了解各個目錄所代表的意義可以更容易找到對應功能的程式碼，這對在核心中探險的我們十分有幫助。&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre class="source-tree literal-block"&gt;
  Linux
  ├── README
  ├── Documentation
  ├── include          // include files needed to build the kernel code
  ├── lib              // kernel's library code
  ├── init             // initialization code for the kernel
  │   └── &lt;span class="blue-b"&gt;main.c&lt;/span&gt;       // start_kernel()
  ├── arch             // architecture specific kernel code
  │   └── *
  │       ├── configs
  │       ├── include
  │       ├── lib
  │       ├── boot
  │       ├── kernel
  │       ├── mm
  │       ├── net
  │       ├── pci
  │       └── crypto
  ├── kernel           // main kernel code
  │   ├── cpu
  │   ├── irq
  │   ├── time
  │   ├── sched
  │   ├── events
  │   ├── power
  │   ├── debug
  │   │&amp;nbsp;&amp;nbsp; └── kdb
  │   ├── gcov
  │   ├── printk
  │   └── trace
  ├── mm               // memory management
  ├── fs               // file system
  ├── firmware
  ├── drivers          // device drivers
  ├── block            // block-device drivers
  ├── sound            // sound drivers
  ├── crypto           // encryption algorithms
  ├── ipc              // inter-process communication
  ├── net              // network protocols
  ├── scripts          // scripts (for example awk and tk scripts) that are used when the kernel is configured
  ├── security         // the security of the kernel
  ├── tools            // the tools that interact with the kernel
  ├── samples          // programming examples
  ├── usr
  └── virt             // virtualization
&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;要更進一步了解關於 Linux kernel source 的目錄結構，Devyn Johnson 有非常詳細的介紹，值得一讀:
&lt;a class="reference external" href="http://www.linux.org/threads/the-linux-kernel-the-source-code.4204/"&gt;How the Linux source code is arranged.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="section" id="kernel-versions"&gt;
&lt;h3&gt;Kernel versions&lt;/h3&gt;
&lt;p&gt;想要了解每個核心版本新增了什麼功能，有什麼變動，可以參考 Linux Kernel Newbies 針對各個核心版本所整理的說明:
&lt;a class="reference external" href="http://kernelnewbies.org/LinuxVersions"&gt;http://kernelnewbies.org/LinuxVersions&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="documentation"&gt;
&lt;h2&gt;Documentation&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;Linux kernel release note: &lt;a class="reference external" href="https://www.kernel.org/doc/readme/README"&gt;README&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;雖說是 release note，但這份文件並沒有列出版本相關的主要變動，它簡單介紹如何設定及編譯 kernel。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;核心內部的文件: &lt;a class="reference external" href="https://www.kernel.org/doc/Documentation/"&gt;https://www.kernel.org/doc/Documentation/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;這些文件說明核心內部各個部份的設計，以及核心的設計原則等。對要參與核心開發的人，這是屬於必讀的文件。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.kernel.org/doc/Documentation/00-INDEX"&gt;Documentation/00-INDEX&lt;/a&gt;
簡介在 Documentation 目錄下各文件及子目錄的內容&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.kernel.org/doc/Documentation/HOWTO"&gt;HOWTO do Linux kernel development&lt;/a&gt;
(&lt;a class="reference external" href="https://www.kernel.org/doc/Documentation/zh_CN/HOWTO"&gt;簡體中文版&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;&lt;a class="reference external" href="https://www.kernel.org/doc/htmldocs/"&gt;Kernel APIs&lt;/a&gt;
整理了各個子系統內部所使用的函式說明，是在追蹤核心程式碼時非常好的參考資料。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="make-targets"&gt;
&lt;h2&gt;Make Targets&lt;/h2&gt;
&lt;p&gt;這份在 Linux kernel 中的文件說明各個 make target 所代表的意義:
&lt;a class="reference external" href="https://www.kernel.org/doc/makehelp.txt"&gt;https://www.kernel.org/doc/makehelp.txt&lt;/a&gt; (事實上，它是 make help 的輸出內容)&lt;/p&gt;
&lt;blockquote&gt;
&lt;table class="docutils field-list" frame="void" rules="none"&gt;
&lt;col class="field-name" /&gt;
&lt;col class="field-body" /&gt;
&lt;tbody valign="top"&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;defconfig:&lt;/th&gt;&lt;td class="field-body"&gt;New config with default from ARCH supplied defconfig&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;menuconfig:&lt;/th&gt;&lt;td class="field-body"&gt;Text based color menus, radiolists &amp;amp; dialogs&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;oldconfig:&lt;/th&gt;&lt;td class="field-body"&gt;Update current config utilising a provided .config as base&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;tags/TAGS:&lt;/th&gt;&lt;td class="field-body"&gt;Generate tags file for editors&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class="field"&gt;&lt;th class="field-name"&gt;cscope:&lt;/th&gt;&lt;td class="field-body"&gt;Generate cscope index&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;
&lt;p&gt;tags 及 cscope 可以配合 vim 來瀏覽核心程式碼，可以參考這篇的說明:
&lt;a class="reference external" href="http://www.cmlab.csie.ntu.edu.tw/~daniel/linux/vim_source_navigation.html"&gt;VIM source navigator&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="news"&gt;
&lt;h2&gt;News&lt;/h2&gt;
&lt;p&gt;要了解 Linux kernel，LWN 是不能錯過的。它的內容包含開放源碼軟體相關的新聞，及 Linux kernel 的開發狀況，而更棒的是它有許多文章解釋 kernel 的設計，是非常好的參考資料來源。
Linux kernel mailing list 是核心開發社群主要的溝通管道，若想追最新的開發狀況，或是參與核心開發的討論，那就是要訂閱它。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;Linux Weeky News (LWN): &lt;a class="reference external" href="https://lwn.net/"&gt;https://lwn.net/&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p class="first"&gt;LWN 根據主題整理的列表 : &lt;a class="reference external" href="http://lwn.net/Kernel/Index/"&gt;http://lwn.net/Kernel/Index/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;這個有點類似精華區，收集了許多說明核心內部設計的文章&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p class="first"&gt;Linux kernel mailing list: &lt;a class="reference external" href="https://lkml.org/"&gt;https://lkml.org/&lt;/a&gt;&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.tux.org/lkml/"&gt;Linux Kernel Mailing List FAQ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://coldnew.github.io/blog/2013/12-19_76c4a/"&gt;codenew: 如何訂閱 Linux Kernel mailing-list&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="books"&gt;
&lt;h2&gt;Books&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.oreilly.com.tw/product_linux.php?id=a194"&gt;Understanding the Linux Kernel&lt;/a&gt; (by Daniel P. Bovet, Marco Cesati)&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.amazon.com/Linux-Kernel-Development-3rd-Edition/dp/0672329468"&gt;Linux Kernel Development&lt;/a&gt; (by Robert Love)&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.wrox.com/WileyCDA/WroxTitle/Professional-Linux-Kernel-Architecture.productCd-0470343435.html"&gt;Professional Linux Kernel Architecture&lt;/a&gt; (by Wolfgang Mauerer)&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://blog.nutsfactory.net/2011/03/17/10-linux-kernel-books/"&gt;Rex: 十本 Linux 核心開發書籍介紹&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="statistic"&gt;
&lt;h2&gt;Statistic&lt;/h2&gt;
&lt;p&gt;下面的網站收集了一些每個版本發布時的統計資料(核心主要的貢獻者及其雇主)，其來源是分析每個提交(commit)上的資料。&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.remword.com/kps_result/"&gt;Linux Kernel Patch Statistic&lt;/a&gt; (統計貢獻者及其雇主)&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.remword.com/kps_result/evolvement.php"&gt;Graphic Kernel Evolvement&lt;/a&gt; (統計每個版本改動的數量)&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="https://www.linuxcounter.net/statistics/kernel"&gt;Linux Counter: Lines of code per kernel version&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://kernelnewbies.org/DevelopmentStatistics"&gt;http://kernelnewbies.org/DevelopmentStatistics&lt;/a&gt; (LWN 每個版本發佈時的統計報告)&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="reference"&gt;
&lt;h2&gt;Reference&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference external" href="https://en.wikipedia.org/wiki/Linux_kernel"&gt;https://en.wikipedia.org/wiki/Linux_kernel&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Linux kernel 新手村: &lt;a class="reference external" href="http://kernelnewbies.org"&gt;http://kernelnewbies.org&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.linux.org/threads/linux-kernel-reading-guide.5384/"&gt;Devyn Johnson: Linux Kernel Reading Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.makelinux.net/"&gt;http://www.makelinux.net/&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.makelinux.net/kernel_map/"&gt;Interactive map of Linux kernel&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.makelinux.net/reference"&gt;http://www.makelinux.net/reference&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.makelinux.net/books/lkd2"&gt;http://www.makelinux.net/books/lkd2&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.ibm.com/developerworks/views/linux/libraryview.jsp"&gt;IBM Developerworks Linux Library&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://www.ibm.com/developerworks/linux/library/l-linux-kernel/"&gt;IBM Developerworks: Anatomy of the Linux kernel&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Kernel Planet (部落格聯播): &lt;a class="reference external" href="http://kernelplanet.org/"&gt;http://kernelplanet.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference external" href="http://lwn.net/Distributions/"&gt;LWN: Linux Distribution List&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Daniel Lin</dc:creator><pubDate>Thu, 24 Dec 2015 00:00:00 +0800</pubDate><guid>tag:danielmaker.github.io,2015-12-24:blog/linux/linux_kernel_beginning.html</guid><category>Linux kernel</category></item><item><title>May The Source Be With You</title><link>https://danielmaker.github.io/blog/about/may-the-source-be-with-you.html</link><description>&lt;img alt="'may-the-source-be-with-you'" src="https://danielmaker.github.io/blog/about/may-the-source-be-with-you.jpg" /&gt;
&lt;p&gt;image by anonymous&lt;/p&gt;
&lt;p&gt;對軟體工程師而言，我們很幸運生在一個開放源始碼如此蓬勃發展的時代，有許多優秀的開源軟體專案可以讓我們好好利用及研究。
就如同一個優秀的文學家經由閱讀其他文學大師的作品來提升自已一樣，軟體工程師也是經由觀摩其他優秀的軟體設計來讓自已的能力提升。
另一方面，開放源碼運動亦造就了軟體開發社群的蓬勃發展，經由分享及社群參與，軟體開發人員之間得以互相切磋討論，集合眾人的力量完成更大的目標，並以開源的方式讓更多人參與。
社群與開放源碼運動之間形成一個密不可分的正向循環，生生不息。
這兩點正是本部落格的目標：藉由分析並學習優秀的開源軟體設計來讓自已的能力提升；藉由分享帶來回饋與交流，形成一個正向循環。&lt;/p&gt;
&lt;p&gt;開源軟體就如同 Star Wars 裡絕地武士的原力一般，如果我們對它夠了解，它將會給我們帶來力量，
它就是我們軟體工程師的原力來源。 May the source be with you.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Daniel Lin</dc:creator><pubDate>Thu, 17 Dec 2015 00:00:00 +0800</pubDate><guid>tag:danielmaker.github.io,2015-12-17:blog/about/may-the-source-be-with-you.html</guid></item></channel></rss>